{
  "id": "68796c79a4ac7ef2a17a618c",
  "lessonNumber": 8,
  "title": "Lesson 08 ‚Äî Introduction to Databases and SQL",
  "status": "pending",
  "assignment": {
    "title": "Assignment for Lesson 8",
    "objective": "No objective specified",
    "expectedCapabilities": [],
    "instructions": [],
    "tasks": [
      {
        "taskNumber": 1,
        "title": "Task 1",
        "description": "Introduction to Databases and SQL**\n\nFor this assignment, you create code in your python_homework/assignment8 folder.\n\n\n## **Task 1: Create a New SQLite Database**\n1. Within your python_homework repository, create an `assignment8` git branch.\n2. Make the `assignment8`  folder the working folder.  Within the `assignment8` folder, create a file `sql_intro.py`.\n3. Write code to connect to a new SQLite database, `../db/magazines.db` and to close the connection.\n4. Execute the script and confirm the database file is created.  Note: All SQL statements should be executed within a `try` block, followed by a corresponing `except` block, because any SQL statement can cause an exception to be raised.\n\n---\n\n## **Task 2: Define Database Structure**\nWe have publishers that publish magazines.  Each publisher has a unique name, and so does each magazine.  There is a one-to-many relationship between publishers and magazines.  We also have subscribers, and each subscriber has a name and an address.  We have a many-to-many association between subscribers and magazines, because a subscriber may subscribe to several magazines, and a magazine may have many subscribers.  So, we have a join table called subscriptions.  The subscriptions table also stores the expiration_date (a string) for the subscription.  All the names, the address, and the expiration_date must be non-null.  \n\n1. Think for a minute.  There is a one-to-many relationship between publishers and magazines.  Which table has a foreign key? Where does the foreigh key point?  How about the subscriptions table: What foreigh keys does it have?\n\n2. Add SQL statements to `sql_intro.py` that create the following tables:\n   - `publishers`\n   - `magazines`\n   - `subscribers`\n   - `subscriptions`\n   Be sure to include the columns you need in each, with the right data types, with UNIQUE and NOT NULL constraints as needed, and with foreign keys as needed.  You can reuse column names if you choose, i.e. you might have a name column for publishers and a name column for magazines.  By the way, if you mess up this or the following steps, you can just delete `db/magazines.db`.\n\n3. Open the `db/magazines.db` file in VSCode to confirm that the tables are created.\n\n---\n\n## **Task 3: Populate Tables with Data**\n1. Add the following line to sql_intro.py, right after the statement that connects to the database:\n   ```\n   conn.execute(\"PRAGMA foreign_keys = 1\")\n   ```\n   This line tells SQLite to make sure the foreign keys are valid.\n2. Create functions, one for each of the tables, to add entries.  Include code to handle exceptions as needed, and to ensure that there is no duplication of information.  The subscribers name and address columns don't have unique values -- you might have several subscribers with the same name -- but when creating a subscriber you should check that you don't already have an entry where BOTH the name and the address are the same as for the one you are trying to create.\n3. Add code to the main line of your program to populate each of the 4 tables with at least 3 entries.  Don't forget the `commit`!\n4. Run the program several times.  View the database to ensure that you are creating the right information, without duplication.\n\n---\n\n## **Task 4: Write SQL Queries**\n1. Write a query to retrieve all information from the subscribers table.\n2. Write a query to retrieve all magazines sorted by name.\n3. Write a query to find magazines for a particular publisher, one of the publishers you created.  This requires a `JOIN`. \n4. Add these queries to your script.  For each, print out all the rows returned by the query.\n\n---\n\n## **Task 5: Read Data into a DataFrame**\n\nYou will now use Pandas to create summary data from the `../db/lesson.db` database you populated as part of the lesson.  We want to find out how many times each product has been ordered, and what was the total price paid by product.\n\n1. While still within the `python_homework/assignment8` directory, create a program, `sql_intro_2.py`.\n2. Read data into a DataFrame, as described in the lesson.  The SQL statement should retrieve the line_item_id, quantity, product_id, product_name, and price from a JOIN of the line_items table and the product table. Hint: Your `ON` statement would be `ON line_items.product_id = products.product_id`.\n3. Print the first 5 lines of the resulting DataFrame.  Run the program to make sure this much works.\n4. Add a column to the DataFrame called \"total\".  This is the quantity times the price.  (This is easy: `df['total'] = df['quantity'] * df['price']`.)  Print out the first 5 lines of the DataFrame to make sure this works.\n5. Add groupby() code to group by the product_id.  Use an agg() method that specifies 'count' for the line_item_id column, 'sum' for the total column, and 'first' for the 'product_name'.  Print out the first 5 lines of the resulting DataFrame.  Run the program to see if it is correct so far.\n6. Sort the DataFrame by the product_name column.\n7. Add code to write this DataFrame to a file `order_summary.csv`, which should be written in the `assignment8` directory.  Verify that this file is correct.\n\nAs we'll learn in the next lesson, the ordering, grouping, count, and sum operations can be done in SQL, more efficiently than in Pandas.  The key concepts of pandas and SQL overlap very strongly.\n\n---\n\n### Submit Your Assignment on GitHub**  \n\nüìå **Follow these steps to submit your work:**  \n\n#### **1Ô∏è‚É£ Add, Commit, and Push Your Changes**  \n- Within your python_homework folder, do a git add and a git commit for the files you have created, so that they are added to the `assignment8` branch.\n- Push that branch to GitHub. \n\n#### **2Ô∏è‚É£ Create a Pull Request**  \n- Log on to your GitHub account.\n- Open your `python_homework` repository.\n- Select your `assignment8` branch.  It should be one or several commits ahead of your main branch.\n- Create a pull request.\n\n#### **3Ô∏è‚É£ Submit Your GitHub Link**  \n- Your browser now has the link to your pull request.  Copy that link. \n- Paste the URL into the **assignment submission form**. \n\n---\n\n\n",
        "codeExample": "",
        "_id": "68796c79a4ac7ef2a17a618e"
      }
    ],
    "submissionInstructions": "Please submit on time",
    "checklist": [],
    "checkForUnderstanding": []
  },
  "subsections": [
    {
      "subsectionOrder": 1,
      "title": "Lesson 8",
      "content": "\n# **Lesson 08 ‚Äî Introduction to Databases and SQL**\n\n## **Lesson Overview**\n**Learning objective**: Students will gain foundational knowledge of SQL databases using Python and SQLite. They will define relational schemas, insert and query data using SQL, handle many-to-many relationships, and interact with databases directly from Pandas for analysis and reporting.\n\n**Topics**:\n1. Introduction to SQL: What SQL is, why relational databases matter, and how constraints, associations, and transactions work.\n2. SQLite Setup: Installing dependencies (Windows only) and connecting to a local SQLite database.\n3. Defining Tables: Creating tables with `CREATE TABLE` statements and specifying primary keys, foreign keys, and constraints.\n4. Populating Tables: Using `INSERT INTO`and parameterized queries to add data to tables.\n5. Querying Data: Writing `SELECT` queries, using `WHERE`, `ORDER BY`, and comparison operators.\n6. Foreign Keys and Relationships: Creating and managing associations using `JOIN` tables.\n7. Joins and Complex Queries: Writing multi-table joins with `JOIN`, `LEFT JOIN`, and `AS` aliases.\n8. Modifying Data: Updating and deleting records using `UPDATE` and `DELETE` statements.\n9. SQL Practice: Practicing queries using the `sqlcommand.py` interface and exploring a sample dataset.\n10. Using SQL with Pandas: Loading SQL query results directly into Pandas DataFrames using `pd.read_sql_query()`.\n11. (Optional) Additional Practice: Guided practice via the SQLBolt tutorial.\n\n## **Setup**\n\nAn additional package is needed for this lesson, but ONLY ON WINDOWS.  Do not install this package if you are on a Mac or Linux, because on those platforms, the capability is part of the Python base.  If you are on Windows, then within the VSCode terminal of your `python_homework` folder, type:\n\n```bash\npip install pyreadline3\n```\n\n### **Topics:**\n\n1. What SQL Is, and Why it is Used\n2. Creating a New SQLite Database\n3. Defining the Database Structure\n4. Populating Tables with Data\n5. Writing SQL Queries\n6. Creating Entries with Foreign Keys\n7. More complicated queries, incuding JOINs\n8. The UPDATE Statement\n9. The Delete Statement\n10. SQL Query Practice\n11. SQL from Pandas\n12. (Optional) More SQL Practice\n\n---\n\n## **7.1 What SQL Is, and Why it is Used**\n\nSQL is the language used to access relational databases.  In a relational database, the data is stored in tables, each of which looks like a spreadsheat.  The database has a schema, and for each table in the database, the schema describes the columns in each table, giving each a name and a datatype.  There aren't many datatypes in a relational database.  We'll use SQLite, and SQLite only supports TEXT, NUMERIC, INTEGER, REAL, or BLOB datatypes.  Other datatypes are supported in SQLite by mapping them to one of these four.  (Other SQL implementations support more.)  One can compare this to no-SQL databases like MongoDB, when you can store any JSON document you like.  The schema can seem like a straitjacket, but it is really more a set of rails, organizing data into a structured form.\n\nRead the following introduction: <https://www.theodinproject.com/lessons/databases-databases-and-sql>.  Or, if you know this stuff, jump to the bottom of that page and do the Knowledge Check.  Be sure that you understand the concepts of Primary Key and Foreign Key.\n\nThere are two important words left out of that introduction: Association and Transaction.\n\n### **Associations**\n\nAn association exists between tables if one table has a foreign key that points to the other.  Consider the following cases:\n\n1. An application has a `users` table and a `user_profiles` table.  Each record in the `user_profiles` table has a foreign key, which is the primary key of a record in the `users` table.  This is a one-to-one association.\n2. An application has blogs.  Each blog has a series of posts.  The application might have a `blogs` table and a `posts` table.  Each record in the `posts` table would have a foreign key for a `blogs` table record, indicating the blog to which it belongs.  This is a one-to-many association, as one blog has many posts.\n3. A magazine publisher has magazines and subscribers.  Each subscriber may subscribe to several magazines, and each magazine may have many subscribers.  Now we have a problem.  \nWe can't put a list of subscribers into a magazine record. Relational database records can't contain lists.  For a given magazine, we could create one record for each subscriber, but we'd be duplicating all the information that describes the magazine many times over.  Similarly, there is no way for the `subscribers` table to contain records for each magazine for each subscriber.  So, you need a table in the middle, sometimes called a **join table**.  In this case, the join table might be `subscriptions`.  Each subscription record has two foreign keys, one for the magazine and one for the subscriber.  This is a many-to many association.\n\n### **Transactions**\n\nA transaction is a write operation on an SQL database that guarantees consistency.  Consider a banking operation.  A user wants to transfer money from one account to another.  The sequence of SQL operations is as follows (this is pseudocode of course):\n\n- Begin the transaction.\n- Read the amount in account A to make sure there's enough.\n- Update that record to decrease the balance by the desired amount.\n- Update that record to increase the balance by the desired amount.\n- Commit the transaction\n\nThe transaction maintains consistency.  When the read occurs, that entry is locked. (This depends on the isolation level and other stuff we won't get into now.)  That lock is important, as otherwise there could be another withdrawal from the account that happens after the read but before the update, and the account would go overdrawn.  Neither do you want the update that decreases the balance to complete while the update that increases the balance in the other account fails.  That would anger the user, and justifiably so.  With transactions, either both write operations succeed or neither succeeds.\n\nRelational databases' strength, by comparision with no-SQL databases, is the efficient handing of structured and interrelated data and transactional operations on that data.\n\n### **Constraints**\n\nWhen a table is defined in the schema, one or several **constraints** on the values may also be specified.\n\n- Datatype constraints: One constraint comes from the datatype of the column: you can't put a TEXT value in an INTEGER column, etc.  \n- NOT NULL constraint:  When present, it means that whenever a record is created or updated, that column in the record must have a value.  \n- UNIQUE constraint: You wouldn't want several users to have the same ID for example.  \n- FOREIGN KEY constraint.  In the blog example above, each post must belong to a blog, meaning that the post record has the blog's primary key as a foreign key.  Otherwise you'd have a post that belonged to no blog, a worthless situation.\n\nIf you try to create a record that doesn't comply with constraints, or update one in violation of constraints, you get an exception.\n\nSQLite, by default, does not turn on the foreign key constraint, but in the examples below, and in most real world situations, you will.\n\n---\n\n## **7.2 Creating a New SQLite Database**\n\n### **Overview**\n\nSQLite is a file-based database, meaning the database itself is stored in a file on disk. Python's `sqlite3` module allows easy interaction with SQLite databases.  It is built into Python, so there is nothing more to install.\n\n### **Creating a Database:**\n\nThe `sqlite3.connect()` statement in Python creates a database if it does not exist.  Then it connects to that database.\n\n1. Open VSCode for your `python_homework` folder.  As you will create files as part of the lesson, create your `assignment7` branch now.\n2. Open your code editor within your `python_homework/assignment7` folder.  Create a new Python script file called `school_a.py`.  In your VSCode terminal, `cd` to the assignment7 folder.\n3. Add the following code to that program to create or connect to a new SQLite database.\n\n### **Example Code:**\n\n```python\nimport sqlite3\n\n# Connect to a new SQLite database\nwith  sqlite3.connect(\"../db/school.db\") as conn:  # Create the file here, so that it is not pushed to GitHub!\n    print(\"Database created and connected successfully.\")\n\n# The \"with\" statement closes the connection at the end of that block.  You could close it explicitly with conn.close(), but in this case\n# the \"with\" statement takes care of that.\n\n```\nRun the program to create a database.\n\n**Outcome:**\n\nRunning the script creates a `school.db` file in the db folder.\n\n## **7.3 Defining the Database Structure**\n\n### **Overview**\n\nDatabases store structured data in tables. SQL queries allow you to define the schema of the tables by specifying columns, data types, and relationships.\n\n### **Steps:**\n\n1. Use SQL `CREATE TABLE` statements to define the structure of your database.  This code is added to `school_a.py`.  **Note** It is best to use `CREATE TABLE IF NOT EXISTS`, as in the example code that follows this section.  Otherwise your code will fail the second time you run it, as the table already exists.\n2. Execute these queries within your Python script using the `execute()` method of a database cursor.\n\n**Tables:**\n\n- **Students:** Contains `student_id`, `name`, `age`, and `major`.\n- **Courses:** Contains `course_id`, `course_name`, and `instructor_name`.\n- **Enrollments:** Contains `enrollment_id`, `student_id`, and `course_id`.\n\n### **Example Code:**\n\n```python\nimport sqlite3\n\n# Connect to the database\nwith sqlite3.connect(\"../db/school.db\") as conn:\n    cursor = conn.cursor()\n\n    # Create tables\n    cursor.execute(\"\"\"\n    CREATE TABLE IF NOT EXISTS Students (\n        student_id INTEGER PRIMARY KEY,\n        name TEXT NOT NULL UNIQUE,\n        age INTEGER,\n        major TEXT\n    )\n    \"\"\")\n\n    cursor.execute(\"\"\"\n    CREATE TABLE IF NOT EXISTS Courses (\n        course_id INTEGER PRIMARY KEY,\n        course_name TEXT NOT NULL UNIQUE,\n        instructor_name TEXT\n    )\n    \"\"\")\n\n    cursor.execute(\"\"\"\n    CREATE TABLE IF NOT EXISTS Enrollments (\n        enrollment_id INTEGER PRIMARY KEY,\n        student_id INTEGER,\n        course_id INTEGER,\n        FOREIGN KEY (student_id) REFERENCES Students (student_id),\n        FOREIGN KEY (course_id) REFERENCES Courses (course_id)\n    )\n    \"\"\")\n\n    print(\"Tables created successfully.\")\n```\n\n### Check for Understanding\n\n1. What kind of association exists between Students and Enrollments?\n\n2. What kind of association exists between Students and Courses?\n\nAnswers:\n\n1. A student may have several or many enrollments, but for each enrollment there is only one student.  This is a one-to-many association between Students and Enrollments.  The student_id is the foreign key.\n\n2. A student may enroll in many courses, and a given course may have many students enrolled.  This is a many-to-many association.  The Enrollments table acts as the join table to tie the two together, and both of its foreign keys are needed to manage the association.\n\n## **7.4 Populating Tables with Data**\n\n### **Overview**\n\nPopulating tables with data helps simulate real-world scenarios, allowing you to practice querying data. Use the `INSERT INTO` SQL query to insert sample records into your tables.\n\n### **Steps:**\n\n1. Create a file in the assignment7 folder called `school_b.py`. Within it, connect to the database, create a curson, and use SQL `INSERT INTO` queries to add data to the tables.\n2. Add a commit() statement\n\n### **Example Code:**\n\n```python\nimport sqlite3 \n\n# Connect to the database\nwith sqlite3.connect(\"../db/school.db\") as conn:\n    conn.execute(\"PRAGMA foreign_keys = 1\") # This turns on the foreign key constraint\n    cursor = conn.cursor()\n\n    # Insert sample data into tables\n    cursor.execute(\"INSERT INTO Students (name, age, major) VALUES ('Alice', 20, 'Computer Science')\")\n    cursor.execute(\"INSERT INTO Students (name, age, major) VALUES ('Bob', 22, 'History')\") \n    cursor.execute(\"INSERT INTO Students (name, age, major) VALUES ('Charlie', 19, 'Biology')\") \n    cursor.execute(\"INSERT INTO Courses (course_name, instructor_name) VALUES ('Math 101', 'Dr. Smith')\")\n    cursor.execute(\"INSERT INTO Courses (course_name, instructor_name) VALUES ('English 101', 'Ms. Jones')\") \n    cursor.execute(\"INSERT INTO Courses (course_name, instructor_name) VALUES ('Chemistry 101', 'Dr. Lee')\") \n\n    conn.commit() \n    # If you don't commit the transaction, it is rolled back at the end of the with statement, and the data is discarded.\n    print(\"Sample data inserted successfully.\")\n```\nNote that you do not have to specify the primary keys (student_id and course_id), although you can.  If you don't specify the primary keys, these are chosen for you, and the primary key column will never be null and will always have unique values.  If you do specify the primary keys, they have to be unique -- there can be no record in that table with the same primary key, or you get an exception.  You notice that there is no 'begin' statement for the commit.  By default, SQLite begins a transaction for you automatically.\n\nAt this point, you should install the SQLite Viewer plugin for your VSCode.  Once you've done that, open the db/school.db file in VSCode, and the tables you have created are displayed, along with any data you have added.\n\nThe INSERT statement can insert several rows in one statement.  You specify multiple sets of values for each of the columns, as follows (you don't need to add this to your program):\n```python\n    cursor.execute(\"INSERT INTO Students (name, age, major) VALUES ('Alice', 20, 'Computer Science'), ('Bob', 22, 'History')\")\n```\n\nNow, you'd like to insert into the Enrollments table as well -- but, each enrollment record has foreign keys, which are primary keys from the Students and Courses tables.  You didn't choose the primary keys above, so you don't know what they are.  You'll solve that problem below.\n\n### Check for Understanding\n\n1. What happens if you try to run your program twice?\n\nAnswer:\n\n1. You get an exception!  Student and course names must be unique.  You need to handle the exceptions!  So change your code as follows:\n\nBut, you still get an exception, for the next Insert.  You need to add the try/except for each of the insert statements.  This seems to violate the DRY principle (Do not Repeat Yourself).  You solve this by creating functions, as follows\n\n```python\nimport sqlite3 \n\n# Connect to the database\n\ndef add_student(cursor, name, age, major):\n    try:\n        cursor.execute(\"INSERT INTO Students (name, age, major) VALUES (?,?,?)\", (name, age, major))\n    except sqlite3.IntegrityError:\n        print(f\"{name} is already in the database.\")\n\ndef add_course(cursor, name, instructor):\n    try:\n        cursor.execute(\"INSERT INTO Courses (course_name, instructor_name) VALUES (?,?)\", (name, instructor))\n    except sqlite3.IntegrityError:\n        print(f\"{name} is already in the database.\")\n\nwith sqlite3.connect(\"../db/school.db\") as conn:\n    conn.execute(\"PRAGMA foreign_keys = 1\") # This turns on the foreign key constraint\n    cursor = conn.cursor()\n\n    # Insert sample data into tables\n\n    add_student(cursor, 'Alice', 20, 'Computer Science')  \n    add_student(cursor, 'Bob', 22, 'History')\n    add_student(cursor, 'Charlie', 19, 'Biology')\n    add_course(cursor, 'Math 101', 'Dr. Smith')\n    add_course(cursor, 'English 101', 'Ms. Jones')\n    add_course(cursor, 'Chemistry 101', 'Dr. Lee')\n\n    conn.commit() \n    # If you don't commit the transaction, it is rolled back at the end of the with statement, and the data is discarded.\n    print(\"Sample data inserted successfully.\")\n```\n\nThe code above uses a **parameterized statement**.  You have `?` markers in the original SQL.  You pass a tuple as a second parameter for the `cursor.execute()`, and the values from the tuple are plugged into the statement in place of the `?` markers.\n\n## **7.5 Writing SQL Queries**\n\n### **Overview**\n\nSQL queries allow you to interact with and analyze data. You will learn how to use SQL commands to retrieve and manipulate data.\n\n**Queries:**\n\nThe SQL statements in this lesson, unless included in Python code, are just examples -- you do not need to add these to your code.\n\n- Retrieve all student information:\n\n```sql\nSELECT * FROM Students;\n```\n\n- Find courses taught by a specific instructor:\n\n```sql\nSELECT * FROM Courses WHERE instructor_name = 'Dr. Smith';\n```\n\n- Find only the student_ids and names from the Student table:\n\n```sql\nSELECT student_id, name FROM Students;\n```\n\n- List students ordered by age:\n\n```sql\nSELECT * FROM Students ORDER BY age;\n```\n\n- Find the students of a given age majoring in English:\n\n```sql\nSELECT * FROM Students WHERE age = 22 AND major = 'History';\n```\n\nWithin Python, SQL SELECT statements are executed like the INSERT statements, but you also need to retrieve the results.  Add the following to your school_b.py program:\n\n```python\n    cursor.execute(\"SELECT * FROM Students WHERE name = 'Alice'\")\n    result = cursor.fetchall()\n    for row in result:\n        print(row)\n```\nWhen the SELECT statement is executed, it makes a collection of rows available.  The fetchall() creates an iterable connection of the matching rows, and each row is a tuple of the values from the requested columns.  In this case, you are using '*' which means all columns.  In this case, the first row returns the record for \"Alice\", and the first element in the tuple is the student_id.\n\n## **7.6 Adding Entries with Foreign Keys**\n\nNow you are ready to add enrollments, because you can resolve the primary keys that are used as foreign keys in the Enrollments table.  The steps are:\n\n1. Find the student_id for the student.\n\n2. Find the course_id for the course.\n\n3. Insert the enrollment record.\n\nYou are going to do this for various students and courses, so again you create a function.  Add this code to school_b.py:\n\n```python\ndef enroll_student(cursor, student, course):\n    cursor.execute(\"SELECT * FROM Students WHERE name = ?\", (student,)) # For a tuple with one element, you need to include the comma\n    results = cursor.fetchall()\n    if len(results) > 0:\n        student_id = results[0][0]\n    else:\n        print(f\"There was no student named {student}.\")\n        return\n    cursor.execute(\"SELECT * FROM Courses WHERE course_name = ?\", (course,))\n    results = cursor.fetchall()\n    if len(results) > 0:\n        course_id = results[0][0]\n    else:\n        print(f\"There was no course named {course}.\")\n        return\n    cursor.execute(\"INSERT INTO Enrollments (student_id, course_id) VALUES (?, ?)\", (student_id, course_id))\n\n    ... # And at the bottom of your \"with\" block\n\n    enroll_student(cursor, \"Alice\", \"Math 101\")\n    enroll_student(cursor, \"Alice\", \"Chemistry 101\")\n    enroll_student(cursor, \"Bob\", \"Math 101\")\n    enroll_student(cursor, \"Bob\", \"English 101\")\n    enroll_student(cursor, \"Charlie\", \"English 101\")\n    conn.commit() # more writes, so we have to commit to make them final!\n```\n\nTry this out, and then view the database in VSCode to see if the entries are created.  You may have to close your view of `school.db` and open it again to see your changes.\n\nYou could add exception handling, but it is not clear which exceptions you might get at this point, so it's not easy to add appropriate exception handling.\n\n### Check for Understanding\n\n1. What would happen if you tried the following:\n    ```python\n    cursor.execute(\"INSERT INTO Enrollments (student_id, course_id) (95, 43)\")\n    ```\n\n2. Try running school_b.py again, and check what happens with Enrollments.  You get duplicate records!  Duplicate, that is, except for the enrollment_id.  How could you prevent this?\n\nAnswer:\n\n1. The foreign key constraint is ON!  You would get an exception.  There is no record in the Students table with a student_id of 95.  There is no record in the Courses table with a course_id of 43, so the foreign key constraint prevents this invalid record from being created.\n\n2. You can't add another UNIQUE constraint to fix this problem, because you need to reuse the course_id and student_id values in multiple records.  But, you can check to see if the record already exists before you do the insert, as follows:\n\n    ```python\n    cursor.execute(\"SELECT * FROM Enrollments WHERE student_id = ? AND course_id = ?\", (student_id, course_id))\n    results = cursor.fetchall()\n    if len(results) > 0:\n        print(f\"Student {student} is already enrolled in course {course}.\")\n        return\n    ```\n    Try this out!\n\n## **7.7 More Complicated Queries**\n\nIn the WHERE clause, you can use various comparison operators such as `< > <= >= <>`.  The `<>` means not equals.  You can also do math, such as `quantity * price`.  And, you can use the LIKE operator to find strings with the `%` sign used as a wildcard.  For example, to find all the math courses, you could do this:\n\n```sql\nSELECT * FROM Courses WHERE course_name LIKE \"math%\";\n```\n### Joins\n\nA join is used within a SELECT statement to combine two or more tables.  The records returned from the SELECT include columns from both tables.  Joins use an ON clause to pair up the entries from each table.  The following SELECT gets the pairs of student name and course name, according to Enrollments, which is the join table.\n```sql\nSELECT Students.name, Courses.course_name FROM Students JOIN Enrollments ON Students.student_id = Enrollments.student_id JOIN Courses ON Enrollments.course_id = Courses.course_id\n```\nThe statement creates a combined row.  For each Student record, the Enrollments for that student are retrieved, and a combined record is created for any matches that are found.  The `ON` clause gives the matching logic.  Then, for each of these combined records, the corresponding Course record is retrieved, and added to the row.  The SELECT returns the name from the Students table and course_name from the Course table.  We can use 'AS' to save typing:\n\n```sql\nSELECT s.name, c.course_name FROM Students AS s JOIN Enrollments AS e ON s.student_id = e.student_id JOIN Courses AS c ON e.course_id = c.course_id;\n```\nAnd, one can even leave out the `AS`:\n```sql\nSELECT s.name, c.course_name FROM Students s JOIN Enrollments e ON s.student_id = e.student_id JOIN Courses c ON e.course_id = c.course_id;\n```\n\nSuppose you want to include customers that have done no orders.  You do a LEFT JOIN (because the customer table is on the left in the join statement.)\n```sql\nSELECT c.customer_name, o.order_id FROM customers c LEFT JOIN orders o on c.customer_id = o.customer_id;\n```\nIf there are customers without orders, this statement will include them in the list, but the order_id column will be empty.  Similarly, one can do a RIGHT JOIN to show the orders without customers ... but there won't be any.  Why? Because the foreign key constraint is on, so you can't have an order record that doesn't belong to a customer.  You can also do a FULL JOIN to get both customers without orders and orders without a corresponding customer.\n\nSuppose we want to list all the students with the corresponding courses for which they are enrolled.  There is, in this case, a many-to-many association between students and courses -- but there is no foreign key in either table that points to the other table.  We need to use the Enrollments table as a join table, combining information from all three tables.  This is a compound join.  You may join three or more tables in this way.\n\n```sql\nSELECT Students.name, Courses.course_name \nFROM Enrollments\nJOIN Students ON Enrollments.student_id = Students.student_id\nJOIN Courses ON Enrollments.course_id = Courses.course_id;\n```\n\n### **Check for Understanding**\n\n1. We see that the JOIN statement for Students and Enrollments has an ON clause with Students.student_id = Enrollments.student_id.  Why doesn't it use Enrollments.enrollment_id?\n\nAnswer:\n\n2. The enrollment_id doesn't correspond to anything in the Students table.  You have to use the foreign key, student_id, from the Enrollments table.  An ON cause typically combines a primary key (Students.student_id) with a foreign key (Enrollments.student_id).  By the way, the primary key doesn't have to have the same name as the foreign key.  If the primary key in the Students table were named `id`, you'd do `ON Students.id = Enrollments.student_id`.\n\n### **Example Code:**\n\nOf course, any of the SQL above can be executed from Python.\n\n\n## **7.8 The UPDATE Statement**\n\nThe UPDATE SQL statement changes one or more existing rows.  You specify the rows you want to change with a WHERE clause, like you would use in a SELECT statement.\n\n```sql\nUPDATE Students SET name=\"Charles\", age=20 WHERE name=\"Charlie\";\n```\nNote that the UPDATE statement updates all rows that match the WHERE clause.  You can also apply math functions to the update, as follows:\n\n```sql\nUPDATE products SET price=price * 1.1;\n```\nThis statement raises all the prices by 10%.  As there is no WHERE statement, every record is changed.\n\n## **7.9 The DELETE Statement**\n\nThe DELETE Statement deletes one or more existing rows.  For example, the following statement deletes all product records if the price is less than 1.00:\n\n```sql\nDELETE FROM products WHERE price<1.0;\n```\nIf you leave off the WHERE clause, it deletes every record in the table!\n\n### **A Reference**\n\nThis is a very brief and incomplete summary of the SQL language.  The SQLBolt tutorial mentioned below gives more complete instruction, and a very good reference is available here: <https://www.w3schools.com/sql/default.asp>.  Some advanced topics, such as aggregation and subqueries, are discussed in the next lesson.\n\n## **7.10 SQL Query Practice**\n\nYour python_homework folder contains a program called `load_db.py`.  Take a look at its contents.  It creates a series of tables, for employees, customers, orders, products, and order_details.  Each order is associated with a customer and an employee.  For each order, there are line_items associated with the order, one line item for each product comprising the order.  You'll see the schema created at the top of the file.  Then, the file uses pandas to load data for each table from csv files into the database.  The resulting database is stored as `./db/lesson.db`.\n\nChange the directory to the python_homework folder and run the `load_db.py` program to create and populate the database.  You can run it again as needed to restore the database to its initial state.  Next, run the `sqlcommand.py` program.  This prompts you with a command line you can use to enter SQL statements.  (Each statement must end with a semicolon.)  Experiment with various SELECT, INSERT, UPDATE, and DELETE statements.  Have a look at the code in `sqlcommand.py` to see how it works.\n\n## **7.11 SQL from Pandas**\n\nHow does a data analyst use SQL?\n\nYou have learned how to load a Pandas DataFrame from a CSV file.  A limitation of CSV files is that they are static.  Each reflects data as it was some time in the past, when the file was written.  Suppose you want to use Pandas to analyse the baseball standings.  These change from day to day -- but instead of a CSV file, one can have a relational database with this information that is updated continuously.  You'd want to load that information into Pandas.  Fortunately, this is very easy. \n\n```python\nimport pandas as pd\nimport sqlite3\n\nwith sqlite3.connect(\"../db/lesson.db\") as conn:\n    sql_statement = \"\"\"SELECT c.customer_name, o.order_id, p.product_name FROM customers c JOIN orders o ON c.customer_id = o.customer_id \n    JOIN line_items li ON o.order_id = li.order_id JOIN products p ON li.product_id = p.product_id;\"\"\"\n    df = pd.read_sql_query(sql_statement, conn)\n    print(df)\n```\nThis loads a dataframe from the results of a SELECT statement.  You then have access to all the statistical power of pandas.  In this case, we get a dataframe that lists all the customer names, all the orders, and the names of all the product that were ordered.  Note that there is a many-to-many association between orders and products, in that an order may have many products, but there may be many orders for a given product. The line_items table acts as a join table for orders and products.\n\n\n## **7.12 Optional: More Practice**\n\nAn excellent tutorial on SQL is available at the following link: <https://sqlbolt.com/>.  This tutorial is optional, but it is **strongly recommended, including the More Topics section**.\n\n### **Summary**\nIn this lesson, you learned:\n\n1. How to create and connect to an SQLite database.\n2. How to define tables using SQL queries.\n3. How to populate tables with sample data.\n4. How to write SQL queries to retrieve and analyze data.\n5. How to commit changes and close the database connection.\n6. How to modify and delete data.\n7. How to access data from Pandas.\n8. By mastering these techniques, you can efficiently interact with databases using Python. For further exploration, refer to the SQLite Documentation and Python‚Äôs sqlite3 library documentation.\n",
      "videoUrl": "",
      "codeExamples": [],
      "externalLinks": [],
      "quizzes": [],
      "_id": "68796c79a4ac7ef2a17a618d"
    }
  ]
}