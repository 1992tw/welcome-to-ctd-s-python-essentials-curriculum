{
  "id": "68796c79a4ac7ef2a17a619c",
  "lessonNumber": 12,
  "title": "Lesson 12 — Advanced Data Visualization Techniques",
  "status": "pending",
  "assignment": {
    "title": "Assignment for Lesson 12",
    "objective": "No objective specified",
    "expectedCapabilities": [],
    "instructions": [],
    "tasks": [
      {
        "taskNumber": 1,
        "title": "Task 1",
        "description": "# Assignment 12: Advanced Data Visualization\n\nThis assignment is to be created in the `assignment12` folder of your `python-assignment12` directory which is a separate repository. Continue to work in the ``assignment12`` branch.\n\n---\n\n\n## **Task 1: Plotting with Pandas**\n1. Create a file called employee_results.py.\n2. Load a DataFrame called employee_results using SQL.  Copy the `db/lesson.db` database from your `python_homework` folder to your `python-assignment12` folder.  Copy the `db` folder and the `lesson.db` file within it.  This can be done using the `cp -r` command.  In your `assignment12` folder, connect to `../db/lesson.db`. You use SQL to join the employees table with the orders table with the line_items table with the products table.  You then group by employee_id, and you SELECT the last_name and revenue, where revenue is the sum of price * quantity.  Ok, that's a lot of SQL to mess with, so here is the statement you need:\n   ```SQL\n   SELECT last_name, SUM(price * quantity) AS revenue FROM employees e JOIN orders o ON e.employee_id = o.employee_id JOIN line_items l ON o.order_id = l.order_id JOIN products p ON l.product_id = p.product_id GROUP BY e.employee_id;\n   ```\n3. Use the Pandas plotting functionality to create a bar chart where the x axis is the employee last name and the y axis is the revenue.\n4. Give appropriate titles, labels, and colors.\n5. Show the plot.\n\n---\n\n## **Task 2: A Line Plot with Pandas**\n1. Create a file called cumulative.py.  The boss wants to see how money is rolling in.  You use SQL to access `../db/lesson.db` again.  You create a DataFrame with the order_id and the total_price for each order.  This requires joining several tables, GROUP BY, SUM, etc.\n2. Add a \"cumulative\" column to the DataFrame.  This is an interesting use of apply():\n   ```python\n   def cumulative(row):\n      totals_above = df['total_price'][0:row.name+1]\n      return totals_above.sum()\n\n   df['cumulative'] = df.apply(cumulative, axis=1)\n   ```\n   Because axis=1, apply() calls the cumulative function once per row.  Do you see why this gives cumulative revenue?  One can instead use cumsum() for the cumulative sum:\n   ```python\n   df['cumulative'] = df['total_price'].cumsum()\n   ```\n3. Use Pandas plotting to create a line plot of cumulative revenue vs. order_id.\n4. Show the Plot.\n\n---\n\n## **Task 3: Interactive Visualizations with Plotly**\n\n1. Load the Plotly wind dataset, via the following:\n   ```python\n   import plotly.express as px\n   import plotly.data as pldata\n   df = pldata.wind(return_type='pandas')\n   ```\n   Print the first and last 10 lines of the DataFrame.\n2. Clean the data.  You need to convert the 'strength' column to a float.  Use of str.replace() with regex is one way to do this, followed by type conversion.\n3. Create an interactive scatter plot of strength vs. frequency, with colors based on the direction.\n4. Save and load the HTML file, as `wind.html`.  Verify that the plot works correctly.\n\n---\n\n## **Task 4: A Dashboard with Dash**\n\nOk, deep breath.  Start by copying `python-assignment12/assignment12/lesson11_c.py` to `python-assignment12/myapp.py`. We can reuse the template.  This is in the root of the project folder because you are going to deploy this to the cloud in Task 5.\n\n1. The dataset to use is the Plotly built in `gapminder` dataset.  This has, among other things, the per capita GDP for various countries for each year.  For a given country, there will be one row per year.  This means that the 'countries' column has many duplicates.\n2. You want a dropdown that has each unique country name. You create a Series called `countries` that is the list of countries with duplicates removed.  You use this Series to populate the dropdown.  Give the dropdown the initial value of 'Canada'.\n3. You give the dropdown the id of 'country-dropdown' and also create a dcc.Graph with id 'gdp-growth'.\n4. You create the decorator for the callback, associating the input with the dropdown and the output with the graph.\n5. The decorator decorates an `update_graph()` function.  This is passed the country name as a parameter.  You need to filter the dataset to get only the rows where the country column matches this name.  Then you create a line plot for 'year' vs. 'gdpPercap`.  Give the plot a descriptive name that includes the country name.\n6. The line to run the app doesn't need to change.\n7. Run the program, and check it out in the browser.  Make bug fixes as needed.\n\n---\n\n## **Task 5: Deploying to Render.com**\n\n1. Create a free account at Render.com.\n2. Change `myapp.py` to add a line:\n   ```python\n   app = Dash(__name__)\n   server = app.server # <-- This is the line you need to add\n   ```\n3. Add, commit, and push your changes to GitHub.  If you are using a branch, create a PR and merge that branch with main.\n4. Go to your render.com dashboard and create a new web service.  Provide the public URL of your python-assignment12 repository.  You must specify a unique name.  The default name is the same as your GitHub repository, so that will likely conflict with another student.\n5. The \"Start Command\" for the web service should be changed to read:\n   ```\n   gunicorn myapp:server\n   ```\n   The gunicorn package is a Python web server, which is used to run the Flask server for your Dash app.\n6. Click the \"Deploy Service\" button.\n7. Wait. Wait. Wait. The Render free plan is not fast.\n8. Eventually, it will say that the service is running.  Wait.  Wait some more.\n9. Click on the https link for your service in the upper part of your render.com dashboard.  Wait.  Wait.  Keep waiting.\n10. After a while, you'll see the app!  Congratulations, you are live! \n\n---\n\n## **Task 6: Reflection**\nCreate a file in the assignment12 folder called reflection.txt, and put in the following thoughts:\n\n1. Reflect on the differences between static and interactive visualizations.\n2. Write a short paragraph discussing the advantages of using dashboards for real-time data exploration.\n3. Explain how interactive tools like Plotly and Dash can improve data communication in professional settings.\n\n## **Task 7: Commit Your Work**\n\nAdd and commit all of the files created for the assignment to the `assignment12` branch.\n\n---\n\n#  Optional Assignment on Streamlit\n\nYou can use either Dash or Streamlit for your capstone project.\n\n## Overview\nThis assignment is to be implemented using **Streamlit**.  \nYou will **import a dataset**, **build a dashboard**, **visualize insights**, **showcase data cleaning**, and **deploy your app** to **Streamlit Community Cloud**.\n\n### Requirements\n- Import a dataset that has already been cleaned and prepared\n- Explain what cleaning and preparation was done\n- Visualize key insights through interactive dashboards\n- Deploy your app using Streamlit Community Cloud\n\n## Task 1: Project Setup\n\n1. Create a new folder called ``streamlit-assignment`` for your project on your local machine.  It will be initialized as a git repository, so make sure it is outside of any other git repository.  \n\n2. Initialize a Git repository inside this folder:\n```bash\ngit init\n```\n\n3. Create a .gitignore file and make sure it includes:\n```bash\n.venv/\n__pycache__/\n*.pyc\n.DS_Store\n```\n\n4. Set up a virtual environment:\n```bash\npython -m venv .venv\nsource .venv/bin/activate  # on macOS/Linux\n.venv\\Scripts\\activate     # on Windows\n```\n\n5. Create requirements.txt file.  You can use the same requirements.txt file which you used for the Streamlit lesson.\n```bash\nstreamlit\npandas\nplotly\nnumpy\nmatplotlib\n```\n6. Install the dependencies. Run following command in your vs code terminal.\n```bash\npip install -r requirements.txt\n```\n7. Create a Python file named `streamlit_app.py` in your project folder.\n   This is the main script Streamlit will run when deploying your app.\n\n## Task 2: Build Your Streamlit Dashboard\n\n### Required Components\n\n1. **Title and Description**\n   - Use `st.title()` and `st.markdown()` to introduce your dashboard\n\n2. **Dataset Overview**\n   - Import your cleaned dataset using Pandas.\n   - Display the dataset using `st.dataframe()` or `st.write()`\n   - Optionally, summarize with `.describe()` or key statistics\n\n3. **Data Cleaning Summary**\n   - Briefly describe what cleaning steps you performed\n   - Optional: Show comparison table (raw vs cleaned)\n\n4. **Visualizations**\n   - Include at least two interactive charts\n   - Examples: bar chart, pie chart, line chart, scatter plot, histogram\n   - Use Streamlit's built-in charts or libraries like Plotly/Matplotlib\n\n\n## Task 3: Deploy Your App\n1. Create a **GitHub repository** and push your code:\n   - Log in to your GitHub account and create a new repository.(https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-new-repository)\n   - Copy the repository URL.\n   - Link your local project folder to the GitHub repository:\n     ```bash\n     git remote add origin <repository-url>\n     ```\n   - Add and commit your changes:\n     ```bash\n     git add .\n     git commit -m \"Initial commit\"\n     ```\n   - Push your code to the GitHub repository:\n     ```bash\n     git branch -M main\n     git push -u origin main\n     ```\n2. Deploy to **Streamlit Community Cloud**:\n   - Visit [Streamlit Cloud](https://streamlit.io/cloud) and log in with your Streamlit account. If you don't have an account, create one using your email or GitHub credentials.\n\n   - Click on the **\"New App\"** button to start the deployment process.\n\n   - In the **\"Select a repository\"** section:\n      - Connect your GitHub account if you haven't already.\n      - Choose the repository where your Streamlit app code is stored.\n\n   - In the **\"Branch\"** dropdown, select the branch containing your code (usually `main`).\n\n   - In the **\"Main file path\"** field, specify the path to your Streamlit app file (e.g., `streamlit_app.py`).\n\n   - Click **\"Deploy\"** to start the deployment process.\n\n   - Wait for the deployment to complete. Once done, you will see a URL where your app is hosted.\n\n   - Test your app by visiting the provided URL to ensure everything works as expected.\n\n   - If you need to make updates to your app, push the changes to your GitHub repository. Streamlit Cloud will automatically redeploy your app with the latest changes.\n3. Verify your app loads successfully and is publicly accessible\n\n## Task 4: Submit Your Assignment\n\n### Required Submissions\n- Your **Streamlit Community Cloud app URL** (deployment link), this link is added to the ``service_urls.txt`` in the ``assignment12` folder in the `python-assignment12` repo.\n- Your **GitHub repository URL** link is also added to the `service_urls.txt`\n- Add and commit the `service_urls.txt` file in the `assignment12` branch.\n\n### Resources\n- [Streamlit Cheat Sheet](https://cheat-sheet.streamlit.app/)\n\n### Example Submissions\n1. Canada Dashboard:\n   - App: https://canada.streamlit.app/\n   - Code: https://github.com/parker84/canada-dashboard\n\n2. Dashboard v2:\n   - App: https://dash-board.streamlit.app/\n   - Code: https://github.com/dataprofessor/dashboard-v2\n\n---\n\n### **Submit Your Assignment on GitHub**  \n\n📌 **Follow these steps to submit your work:**  \n\n#### **1️⃣ Add, Commit, and Push Your Changes** \n- Create a file called `service_urls.txt` in the assignment12 folder.  In it, paste the URL for your Render.com service.  If you did the Streamlit assignment, make sure the Streamlit github repository url and streamlit.io service url are added to the `service_urls.txt` file as well.\n- Within your `python-assignment12` folder, do a git add and a git commit for the files you have created, so that they are added to the `assignment12` branch.\n- Push that branch to GitHub. \n\n#### **2️⃣ Create a Pull Request**  \n- Log on to your GitHub account.\n- Open your `python-assignment12` repository.\n- Select your `assignment12` branch.  It should be one or several commits ahead of your main branch.\n- Create a pull request.\n\n#### **3️⃣ Submit Your GitHub Link**  \n- Your browser now has the link to your pull request.  Copy that link. \n- Paste the URL into the **assignment submission form**.\n- if you did the optional Streamlit assignment, make sure that repository link and the url for the streamlit.io service are included in the `service_urls.txt` file. \n\nTo summarize, a pull request for the `assignment12` branch in your new `python-assignment12` repository is pasted into the link submission field in the **assignment submission form**.  The `render.com` Dash service is published in `service_urls.txt` file. If you do the streamlit assignment, the link for the `streamlit-assignment` repository and the url for the `streamlit.io` service are included in the `service_urls.txt` file.\n\n---\n",
        "codeExample": "",
        "_id": "68796c79a4ac7ef2a17a619e"
      }
    ],
    "submissionInstructions": "Please submit on time",
    "checklist": [],
    "checkForUnderstanding": []
  },
  "subsections": [
    {
      "subsectionOrder": 1,
      "title": "Lesson 12",
      "content": "\n# **Lesson 12 — Advanced Data Visualization Techniques**\n\n## **Lesson Overview**\n**Learning objective:** students will learn how to build advanced, interactive visualizations using Python libraries such as Pandas, Plotly, and Dash. They will practice visualizing data from DataFrames, creating interactive charts, and developing simple dashboards for real-time data exploration. To prepare for the final project, students will complete this lesson and assignment in a personal GitHub repository rather than in `python_homework`. An optional section introduces Streamlit as an alternative to Dash for dashboard development.\n\n### **Topics:**\n1. Plotting with Pandas: Visualizing data directly from DataFrames.\n2. Interactive Visualizations: Using Plotly for interactive plotting.\n3. Dashboards: Creating dynamic dashboards with Plotly and Dash.\n4. Advanced Customization: Advanced interactivity, subplots, and real-time updates.\n5. Optional lesson on Streamlit\n6. Dash and Streamlit compared.\n\nNote:\nFor your final project, you will create a dashboard using one of these tools.  Which one you use is up to you.  Check out the optional Streamlit information and assignment if you are interested in Streamlit.\n\n### **Setup**\n\nYou are using your own repository, both for the lesson and for the assignment.  If you do the Streamlit portions, these are also to be done within a second new repository.  The steps are these:\n\n1. Create a folder called  `python-assignment11`.  This should **not** be inside of the `python_homework` folder.  Change to this directory.\n2. Do a `git init`.\n3. Create a `.gitignore` file.  You can copy the one from `python_homework`, but be sure you know why that one says what it does.\n4. Create a virtual environment called `.venv`.  See the README.md for `python_homework` if you don't remember how this is done.\n5. Create a `requirements.txt` file.  This should include the following packages.  These will also cover the optional streamlit lesson.\n    - numpy\n    - pandas\n    - matplotlib\n    - plotly\n    - seaborn\n    - dash\n    - gunicorn\n    - streamlit\n    \n    If you do the Streamlit assignment, some further setup is needed since a separate repo will be created.  You can specify specific versions of these packages (see the requirements.txt for `python_homework`), but if you don't, you will get the latest version of each of these.\n6.  **Important** Activate the virtual environment, with the command:\n    ```bash\n    source .venv/bin/activate\n    ```\n    Or, for Windows Git Bash:\n    ```bash\n    source .venv/Scripts/activate\n    ```\n    Verify that the virtual environment is active with:\n    ```bash\n    which python\n    ```\n    This should return a python location within your python-assignment11 folder.\n7. Load the required packages as follows:\n    ```bash\n    pip install -r requirements.txt\n    ```\n8. Do `VSCode .`.  Bring up VSCode command palette (Ctrl-Shift-P) and select Python: Select Interpreter.  Select the one with `.venv`.  Close any VSCode terminal sessions and start a new one.  You should see in the command prompt that `.venv` is active.\n9. On GitHub, create a new public repository called python-assignment11.  Do not create a README.md or .gitignore or license.  Copy the URL of the repository.  You can use either the HTTL or SSH URL, depending on your preference.  Set the remote for the repository, and push your code.\n    ```bash\n    git remote add origin <url>\n    git add -A\n    git commit -m \"first commit\"\n    git push origin main\n    ```\n10. Create an `assignment11` git branch. Create a folder called `assignment11`.  This is for the exercises prior to the assignment and will also be used for the assignment.\n\nFor the following code examples, you create programs in the `assignment11` folder.  Some of this code won't run correctly within the Python interactive shell.  As you do the lesson and assignment, periodically add and commit your changes and push the `assignment11` branch to GitHub.  This is to practice the procedures of a development shop.  When you use these procedures, you can be confident that you won't break something and have to start over.  You can just switch back to the last commit if something breaks.\n\n---\n\n## **11.1 Plotting with Pandas**\n\n### **Overview**\nPandas simplifies data visualization by providing built-in plotting methods for DataFrames and Series. These plots are ideal for quick data exploration and basic visualizations.\n\n### **Key Plot Types:**\n- **Line Plot:** Displays trends over time or continuous data.\n- **Bar Plot:** Used for comparing categorical data.\n- **Histogram:** Shows the distribution of numerical data.\n\n### **When to Use These Plots:**\n- **Line Plots** are typically used for showing data trends over time, such as sales or stock prices over months.\n- **Bar Plots** are ideal when you need to compare quantities between different categories, such as the sales of different products or regions.\n- **Histograms** are useful for analyzing the distribution of numerical data, identifying patterns, skewness, or the range of values.\n\nWithin the `assignment11` folder of your `python-assignment11` directory, create `lesson11_a.py`.  This code uses the DataFrame plot() method, which is part of Pandas, but, to actually display the plot, you also need Matplotlib, to do the `show()`.  Your program should contain the following code:\n\n### **Example Code: Plotting with Pandas**\n\nCreate a file called `lesson11_a.py`, with the following content:\n\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load a dataset\ndata = {\n    \"Month\": [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"],\n    \"Sales\": [100, 150, 200, 250, 300, 350],\n    \"Expenses\": [80, 120, 180, 200, 220, 300]\n}\ndf = pd.DataFrame(data)\n\n# Line Plot\ndf.plot(x=\"Month\", y=[\"Sales\", \"Expenses\"], kind=\"line\", title=\"Sales vs. Expenses\")\nplt.show()\n\n# Bar Plot\ndf.plot(x=\"Month\", y=\"Sales\", kind=\"bar\", color=\"skyblue\", title=\"Monthly Sales\")\nplt.show()\n```\n\nTry this out.  The behavior of Matplotlib is like what you saw in the previous lesson.  A graphic window appears, and the program stops to wait at that point, until you close the window.\n---\n\n## **11.2 Interactive Visualizations with Plotly**\n\n### **Overview**\nPlotly is a powerful library for creating interactive, highly customizable plots. It allows for hover tooltips, zooming, and dynamic interactions that improve user experience.  The code below uses a sample dataset that is provided as part of Plotly, but in the general case, you would use a Pandas DataFrame loaded from a CSV file or database.  Within the `assignment11` folder, create `lesson11_b.py` with the following code:\n\n### **Example Code: Interactive Scatter Plot**\n```python\nimport plotly.express as px\nimport plotly.data as pldata\n\n\ndf = pldata.iris(return_type='pandas') # Returns a DataFrame.  plotly.data has a number of sample datasets included.\nfig = px.scatter(df, x='sepal_length', y='petal_length', color='species',\n                 title=\"Iris Data, Sepal vs. Petal Length\", hover_data=[\"petal_length\"])\nfig.write_html(\"iris.html\", auto_open=True)\n\n# Do not try fig.show()!  This sometimes works, but usually it just hangs.\n```\nTry it out!  The interactive plot comes up in your browser, and you can hover over data points zoom, select, etc.  The HTML file (with lots of embedded JavaScript) can be used in other contexts.exit\n\n### **Key Features of Plotly:**\n- **Interactivity:** Hover tooltips, zooming, and panning.\n- **Customization:** Wide range of customization options for visual aesthetics and user interaction.\n\n---\n\n## **11.3 Building Dashboards with Dash**\n\n### **Overview**\nDash is a framework for creating interactive web applications in Python. It leverages Plotly for visualizations and allows you to create dashboards that update in real-time based on user input.  When you install Dash, you also install Flask as a dependency.  Flask is a web application server framework, like Node or Rails, but in Python.  When you run a Dash dashboard, the Flask server runs.  Dash pages are dynamic, in that you can add dropdown lists or other controls to affect what is displayed.  Within the `assignment11` folder, create a file `lesson11_c.py`, with the following content:\n\n### **Example Code: Simple Dashboard**\n```python\nfrom dash import Dash, dcc, html, Input, Output\nimport plotly.express as px\nimport plotly.data as pldata\n\ndf = pldata.stocks(return_type='pandas', indexed=False, datetimes=True)\n\n\n# Initialize Dash app\napp = Dash(__name__)\n\n# Layout\napp.layout = html.Div([\n    dcc.Dropdown(\n        id=\"stock-dropdown\",\n        options=[{\"label\": symbol, \"value\": symbol} for symbol in df.columns],\n        value=\"GOOG\"\n    ),\n    dcc.Graph(id=\"stock-price\")\n])\n\n# Callback for dynamic updates\n@app.callback(\n    Output(\"stock-price\", \"figure\"),\n    [Input(\"stock-dropdown\", \"value\")]\n)\ndef update_graph(symbol):\n    fig = px.line(df, x=\"date\", y=symbol, title=f\"{symbol} Price\")\n    return fig\n\n# Run the app\nif __name__ == \"__main__\": \n    app.run(debug=True) \n```\n\nOk, now run this file.  And, what seems to happen is ... nothing, except the program seems to hang.  But, actually, you have started a web server.  Use your web browser to connect to it, at `http://localhost:8050`.  You see the interactive chart!  At the top, you can select a stock symbol, and you see the corresponding line chart for the stock price.  Sometimes you might have a port conflict, in which case you can specify an alternate port, by adding `port=8055` or some such port to your app.run() statement.\n\nNow, to explain the code above.  This code uses another sample dataset built into Plotly.  That is loaded via the `pldata.stocks()` statement above.  You can find these documented here: [https://plotly.com/python-api-reference/generated/plotly.data.html].  Of course, you could load a CSV file instead.  \n\nTo explain the code, a bunch of comments are added below.\n\n```python\nfrom dash import Dash, dcc, html, Input, Output # Dash components you need\nimport plotly.express as px # Dash relies on Plotly to actually do the plotting.  Plotly creates an HTML page with lots of JavaScript.\nimport plotly.data as pldata # This is only needed to give access to the Plotly built in datasets.\n\ndf = pldata.stocks(return_type='pandas', indexed=False, datetimes=True) # This loads one of the datasets\n\n\n# Initialize Dash app\napp = Dash(__name__) # This creates the app object, to wich various things are added below. \n# __name__ is the name of the running Python module, which is your main module in this case\n\n# Layout: This section creates the HTML components\napp.layout = html.Div([ # This div is for the dropdown you see at the top, and also for the graph itself\n    dcc.Dropdown( # This creates the dropdown\n        id=\"stock-dropdown\", # and it needs an id\n        options=[{\"label\": symbol, \"value\": symbol} for symbol in df.columns], # This populates the dropdown with the list of stocks\n        value=\"GOOG\" # This is the initial value\n    ),\n    dcc.Graph(id=\"stock-price\") # And the graph itself has to have an ID\n])\n\n# Callback for dynamic updates\n@app.callback( # OK, now this is a decorator.  Hmm, we haven't talked about decorators in Python.  This decorator is decorating the update_graph() function.\n    # Because of the decorator, the update_graph() will be called when the stock-dropdown changes, passing the value selected in the dropdown.\n    Output(\"stock-price\", \"figure\"),  # And ... you get the graph back\n    [Input(\"stock-dropdown\", \"value\")] # When you pass in the value of the dropdown.\n)\ndef update_graph(symbol): # This function is what actually does the plot, by calling Plotly, in this case a line chart of date (which is the index) vs. the chosen stock price.\n    fig = px.line(df, df.index, y=symbol, title=f\"{symbol} Price\")\n    return fig\n\n# Run the app\nif __name__ == \"__main__\": # if this is the main module of the program, and not something included by a different module\n    app.run(debug=True) # start the Flask web server\n```\nWe'll explain decorators in the next lesson, but here is some additional explanation on the `@app.callback` decorator.  That decorator is provided by Dash and is associated with the app object.  Within your `app.layout`, you can have one or several HTML controls, each with an ID.  In this case, you have just one, the dropdown.  When you use `app.@callback`, the function that follows (the function is update_graph() in this case) will be called any time one of the controls that is specified as an Input for that callback has a change in value, that is, each time the user enters or clicks on something.  The changed value or, in the case of multiple Inputs, the changed values, are then passed to the decorated function.  That function returns the Output, in this case a graph.  (It is also possible to have multiple Outputs for the callback, but that's beyond the scope of this lesson.)  You can have multiple `@app.callback` decorator statements within a Dash program, each decorating a different function.  So, for example, you could have several different graphs on the page, each of which is controlled by a different set of HTML controls.\n\nWhew, clear as mud, eh?  Let's give a summary of how Dash works.\n\n### **A Summary of Dash**\n\n1. The app: You always create an app, with `app = Dash(__name__)`.  This gives you access to `app.layout()` and `@app.callback()`.\n2. HTML components: You declare these with `html.something()`.  This is the usual list of html components: div, container, paragraph, whatever, nested as you choose, and styled as you choose.  (Styling is out of scope for this lesson, but there is, for example, a Bootstrap package for Dash.)\n3. Dynamic components and controls: You declare these with `dcc.something()`.  These are (a) components you want to modify in response to user input, or (b) controls that catch that user input.  For controls, you have the usual list: radio buttons, dropdowns, input, sliders, tabs, etc.  For components you update, one is `dcc.graph`, but you can update a paragraph or div or whatever you like.  One useful thing to update is a data table, You import dash_table from dash, and then do a `dash_table.DataTable(...)`.  You can create pandas DataFrames, convert them to dicts, and display them in the table.\n4. Callbacks.  If you have controls, you will have one or more functions that are decorated with @app.callback.  As follows:\n    ```python\n    @app.callback(Output(id, what), [Input(id, value), Input(id2, value2), ...])\n    update_function(value, value2, ...):\n        # logic depending on the values passed\n        ...\n        return what\n    ```\n    Let's break this down.  The Output specifies the id of the HTML element to update, and the attribute (what) of that component that is to be changed.  You have a list of one or more inputs, and for each, you have the id of the HTML control and the value it has.  (Note that for a multi-select list, `value` may be a list.)  Any time the value of one of these controls changes as a result of user input, the update_function() will be called so that it can do its thing and return the updated stuff.  Several different update functions might be registered for the same input, so as to update different HTML elements when a particular control or set of controls changes.\n\nThat's Dash in a nutshell.  Your homework doesn't include DataTable, but maybe it should, as DataTable provides a way to display DataFrames.  The DataTable works like:\n\n```python\nimport pandas as pd\nfrom dash import dash_table, Dash, html\n\napp = Dash(__name__)\n\ndf = pd.read_csv(\"some csv file\")\n\napp.layout = html.Div([dash_table.DataTable(df.to_dict('records'), [{\"name\": i, \"id\": i} for i in df.columns], id='tbl')])\n```\nAnd you can make the table interactive, for example by having a callback any time a cell is clicked.  \n\nTo understand Dash and Plotly fully, you need to spend time studying the Plotly and Dash documentation, or perhaps by asking your friendly AI how to do this or that.\n\n---\n\n## **11.4 Reflection**\n\n### **Differences Between Static and Interactive Visualizations:**\n- **Static Visualizations:** Easier to create and quicker to render but lack user interaction.\n- **Interactive Visualizations:** Allow users to explore data, zoom, filter, and interact, providing a deeper and more engaging analysis experience.\n\n### **Advantages of Dashboards:**\n- Real-time data exploration and updates.\n- User interaction with data (e.g., dropdowns, sliders) enables custom insights.\n- Efficient presentation of key metrics in a professional setting.\n\n---\n\n# Building Interactive Apps with Streamlit\n\nThis portion of the lesson supports the optional assignment on Streamlit.  For the capstone final project, you can use either Dash or Streamlit.\n\n## Lesson Overview\n\n**Learning objective:** Learn to create interactive web applications for data visualization and analysis using Streamlit.\n\nTopics: \n  * Introduction to Streamlit and its benefits\n  * Basic Streamlit components and layout\n  * Interactive data visualization with Streamlit\n  * Deploying Streamlit applications\n\n## What is Streamlit?\n\nStreamlit is a Python library that makes it easy to create custom web apps for machine learning and data science. It turns data scripts into shareable web apps in minutes, not weeks.\n\n### Key Features\n* Simple Python-first syntax\n* Rich set of UI components\n* Easy integration with data science libraries\n* Quick deployment options\n\n### Installation and Setup\n\nFirst, let's set up a virtual environment and install Streamlit:\n\n1. Create a project folder named `streamlit_project` in the top level of your `assignment11` folder and change to that folder.\n\n## Basic Streamlit Components\n### Text and Data Display\n\nStreamlit provides a variety of methods to render static content such as text, markdown, and code. These elements are useful for building the layout and guiding users through your app.\n\n#### Exercise 1: Text and Data Display\n- Create a python script app.py\nIn this exercise, you will add static content to your app by writing the following code into your app.py file:\n```python\nimport streamlit as st  # Importing the Streamlit library\n\n# Basic text elements\nst.title(\"My First Streamlit App\")  # Adds a big title at the top of the app\nst.header(\"Section 1\")  # Adds a section header — good for breaking content into parts\nst.subheader(\"Header\")  # Slightly smaller than header — useful for structure\nst.subheader(\"Subheader\")  # Another level down — keeps things organized\nst.text(\"Simple text\")  # Displays plain, unformatted text — like a basic message\nst.markdown(\"**Bold** and *italic* text\")  # Markdown lets you add simple formatting like bold and italics\n\n# Display data\nst.write(\"Automatic data display\")  # Streamlit's flexible method — handles strings, numbers, dataframes, and more\nst.code(\"print('Hello World')\", language='python')  # Nicely formats code blocks with syntax highlighting\nst.latex(r\"\\int_{a}^{b} x^2 dx\")  # Renders LaTeX math formulas — great for equations\n\n```\n\nOnce you've saved and run your app.py file using the command:\n\n```bash \nstreamlit run app.py\n```\nOpen your browser to http://localhost:8501 to view your app.\n\nNote: Any time you change a value in one of the input components, go to the browser tab and refresh ,Streamlit  reruns the entire script from top to bottom using the updated values. This means your app always reflects the latest state .\nYou can refresh the tab manually, or use the “Always rerun” option in the top-right of the Streamlit page for instant updates as you code.\n\n#### Exercise - 2\n### Data Input Components\n```python\n# Text input\nst.header(\"Section 2\")  # A new section to group interactive input components\nname = st.text_input(\"Enter your name\", \"John Doe\")  # Simple text field with a default value\ndescription = st.text_area(\"Description\", \"Write something...\")  # Multi-line text box for longer input\n\n# Numeric input\nage = st.number_input(\"Age\", min_value=0, max_value=120, value=25)  # Number picker with min/max range\nscore = st.slider(\"Score\", 0, 100, 50)  # Slider to pick a number in a range — great for ratings or scores\n\n# Selection widgets\noption = st.selectbox(\"Choose an option\", [\"A\", \"B\", \"C\"])  # Dropdown menu — user picks one option\noptions = st.multiselect(\"Multiple options\", [\"X\", \"Y\", \"Z\"])  # Allows multiple selections at once\n\n# Date and time\ndate = st.date_input(\"Select date\")  # Calendar-style date picker\ntime = st.time_input(\"Select time\")  # Clock-style time picker\n\n# Buttons and checkbox\nif st.button(\"Click me\"):  # A button that runs code when clicked\n    st.write(\"Button clicked!\")  # Responds when the button is pressed\n    \nif st.checkbox(\"Show/Hide\"):  # Checkbox to toggle something on/off\n    st.write(\"Visible content\")  # Displays this text only if the box is checked\n```\n- you can again now refresh your tab in browser to see the updated output.\n\nNote:Unlike dropdowns or sliders (which always keep a selected value), buttons in Streamlit are \"stateless\" — they don’t hold their state after being clicked. Instead, Streamlit checks whether the button was pressed during that specific run of the script. That’s why we use an if statement with them.\n\nAlso, clicking a button triggers a full rerun of the script, just like other controls.\n\nNote: 📍 Where does st.write() show output?\nStreamlit renders output in the order the code runs — so the st.write() here appears right under the button. To control placement more precisely, you can use layout elements like columns or placeholders.\n\n\n## Exercise 3: Layout and Containers\nIn this section, you’ll learn how to organize your app using columns, expanders, and a sidebar.\n\nContinue working in the same app.py file you created earlier. You can either:\n-Append the new code at the bottom of the file\n\n\n\n```python\nst.header(\"Section 3\")\n\n# Create two side-by-side columns\ncol1, col2 = st.columns(2)\n\nwith col1:  # Everything under this goes into the left column\n    st.header(\"Column 1\")\n    st.write(\"Content for column 1\")\n\nwith col2:  # Everything under this goes into the right column\n    st.header(\"Column 2\")\n    st.write(\"Content for column 2\")\n\n# Expandable sections\nwith st.expander(\"Click to expand\"):\n    st.write(\"Expanded content here\")\n\n# Sidebar\nst.sidebar.title(\"Sidebar\")\nsidebar_option = st.sidebar.selectbox(\"Select option\", [\"A\", \"B\", \"C\"])\n```\n\nStreamlit uses the Python with statement to define scoped areas for content. \n```python\nwith col1:\n    st.write(\"Some content\")\n```\n…it means \"put this content inside column 1.\" Streamlit handles layout placement based on these scopes — it’s a readable way to group content visually.\n\n\n\n## Exercise 4: Building a Simple Dashboard\n\nCreate a new python script named 'dashboard_app.py'.\n\n```python\nimport streamlit as st  \nimport pandas as pd     # Used to work with tabular data\nimport numpy as np      # Helps generate random numbers\nimport plotly.express as px  # For interactive charts\n\n# Create sample data — just faking some numbers to simulate a small product dataset\nnp.random.seed(42)  # Setting a seed so results are consistent every time you run\nsample_data = {\n    'Product': ['Product A', 'Product B', 'Product C', 'Product D'],\n    'Sales': np.random.randint(100, 500, size=4),   # Random sales numbers\n    'Profit': np.random.randint(20, 100, size=4)    # Random profit numbers\n}\ndf = pd.DataFrame(sample_data)  # Convert the data into a DataFrame for easy handling\n\n# Sidebar filters — this shows up in the sidebar for user interaction\nst.sidebar.header('Filter Options')  # Sidebar title\nselected_product = st.sidebar.selectbox('Select Product', df['Product'])  # Dropdown to choose a product\n\n# Filter the data based on the user's selection\nfiltered_df = df[df['Product'] == selected_product]  # Show only the row that matches the selected product\n\n# Main app content starts here\nst.title('Simple Product Dashboard')  # Big title for the dashboard\n\n# Display key numbers using metrics — side-by-side using columns\ncol1, col2 = st.columns(2)  # Create two columns for layout\nwith col1:\n    st.metric('Sales', f\"${filtered_df['Sales'].values[0]:,}\")  # Show sales in a pretty format\nwith col2:\n    st.metric('Profit', f\"${filtered_df['Profit'].values[0]:,}\")  # Show profit similarly\n\n# Add a bar chart comparing all products — gives full context beyond the filter\nst.subheader('Sales and Profit Comparison')  # Subheading for the chart\nbar_chart = px.bar(df, x='Product', y=['Sales', 'Profit'], barmode='group')  # Grouped bar chart\nst.plotly_chart(bar_chart)  # Render the chart in the app\n```\n\nin your terminal execute\n```bash\nstreamlit run dashboard_app.py\n```\n\nIf you completed the Streamlit lesson, add and commit the additional folder and files created.\n\n## Conclusion\n You now know how to:\n- Create basic Streamlit apps\n- Add input forms, layouts, and sidebars\n- Build simple dashboards with metrics and charts\n\n## ** Dash and Streamlit**\n\nStreamlit, like Dash, is a way of creating a web based dashboard for data presentation.\n\nAdvantages of Dash:\n- Widely used\n- Gives you a lot of control, all the power that you have in any front end framework\n- Better for large complicated projects\n\nDisadvantages of Dash:\n- Steep learning curve\n\nAdvantages of Streamlit:\n- Pretty easy as compared with Dash\n\nDisadvantages:\n- Not as widely used (though gaining popularity)\n- In a production environment, it is not very scalable\n\n\n## **Summary**\n\nIn this lesson, you learned:\n1. How to visualize data directly from Pandas DataFrames.\n2. How to create interactive visualizations with Plotly.\n3. How to build dynamic dashboards using Dash.\n4. The differences between static and interactive visualizations and their real-world applications.\n\nFor more details, explore the [Plotly Documentation](https://plotly.com/python/) and [Dash Documentation](https://dash.plotly.com/).\n\n---\n\n### Additional Resources:\n1. **Matplotlib Tutorials:** For more detailed Matplotlib tutorials, check out [Matplotlib Tutorials](https://matplotlib.org/stable/tutorials/index.html).\n2. **Seaborn Gallery:** Explore different plot examples at the [Seaborn Gallery](https://seaborn.pydata.org/examples/index.html).\n3. **Data Visualization in Python:** To explore more about data visualization strategies and best practices, visit [Data Visualization in Python](https://realpython.com/python-data-visualization-using-matplotlib/).\n\n",
      "videoUrl": "",
      "codeExamples": [],
      "externalLinks": [],
      "quizzes": [],
      "_id": "68796c79a4ac7ef2a17a619d"
    }
  ]
}