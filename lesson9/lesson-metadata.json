{
  "id": "68796c79a4ac7ef2a17a6190",
  "lessonNumber": 9,
  "title": "Lesson 09 ‚Äî Advanced SQL and Database Integration",
  "status": "pending",
  "assignment": {
    "title": "Assignment for Lesson 9",
    "objective": "No objective specified",
    "expectedCapabilities": [],
    "instructions": [],
    "tasks": [
      {
        "taskNumber": 1,
        "title": "Task 1",
        "description": "\n# **Advanced SQL and Database Integration**\n\n---\n\n## **Lesson Overview**\n\n**Learning Objective**:  \nStudents will deepen their understanding of SQL by learning advanced techniques such as subqueries, complex `JOIN`s, aggregation with functions, and using the `HAVING` clause for conditional filtering.\n\n---\n\n## **Assignment Instructions**\n\nYou create the code for this assignment in your python_homework/assignment9 folder.  You may want to have two VSCode terminal sessions.  In one, you have changed directories to `assignment9`.  This is the session where you will run your code.  In the other terminal session, you will run `sqlcommand.py` from the `python_homework` folder.  You need to have the working directory set differently, so that each program will be able to find `db/lesson.db`.  Be sure to create an `assignment9` git branch before you start.  As usual, mark the code that completes each task with a comment line.\n\n### **Preparation and Practice**\n\nYou have already experimented with the `sqlcommand.py` program.  Run it again, and practice what you've learned.  You can do SELECT, INSERT, UPDATE and DELETE.  The SELECT statements can have JOIN, GROUP BY, ORDER BY, subqueries, HAVING, etc.  Practice these until you feel familiar with them.\n\nFor each of the following tasks, you first use the sqlcommand command line to get the right SQL statement.  Then you add it to your program.\n\n**Help Available!**  \n\nThis lesson combines a lot of concepts that have been presented only briefly. You may find these tasks a little challenging.  If you get stuck, 1:1 mentors are available to answer your questions.  Appointments are available in the [1:1 Mentor Table](https://airtable.com/appoSRJMlXH9KvE6w/shrQinGb1phZYwdiL)\n\n---\n\n### **Task 1: Complex JOINs with Aggregation**\n\n1. **Problem Statement**:  \n   Find the total price of each of the first 5 orders.  There are several steps.  You need to join the orders table with the line_items table and the products table.  You need to GROUP_BY the order_id.  You need to select the order_id and the SUM of the product price times the line_item quantity.  Then, you ORDER BY order_id and LIMIT 5.  You don't need a subquery. Print out the order_id and the total price for each of the rows returned.\n\n2. **Deliverable**: \n   - Within the python_homework folder, create an `assignment9` branch.  Change to the `assignment9` folder.\n   - Get the SQL statement working in sqlcommand.\n   - Within the `assignment9` folder, create `advanced_sql.py`. This should open the database, issue the SQL statement, print out the result, and close the database.\n   - test your program.\n\n---\n\n### **Task 2: Understanding Subqueries**\n\n1. **Problem Statement**:  \n   For each customer, find the average price of their orders.  This can be done with a subquery. You compute the price of each order as in part 1, but you return the customer_id and the total_price.  That's the subquery. You need to return the total price using `AS total_price`, and you need to return the customer_id with `AS customer_id_b`, for reasons that will be clear in a moment.  In your main statement, you left join the customer table with the results of the subquery, using `ON customer_id = customer_id_b`.  You aliased the customer_id column in the subquery so that the column names wouldn't collide.  Then group by customer_id -- this `GROUP BY` comes *after* the subquery -- and get the average of the total price of the customer orders.  Return the customer name and the average_total_price.\n\n2. **Deliverable**:  \n   - Again, get the SQL statement working in sqlcommand.\n   - Add code to `advanced_sql.py` to print out the result.\n\n---\n\n### **Task 3: An Insert Transaction Based on Data**\n\n1. **Problem Statement**:  \n   You want to create a new order for the customer named Perez and Sons.  The employee creating the order is Miranda Harris.  The customer wants 10 of each of the 5 least expensive products.  You first need to do a SELECT statement to retrieve the customer_id, another to retrieve the product_ids of the 5 least expensive products, and another to retrieve the employee_id.  Then, you create the order record and the 5 line_item records comprising the order.  You have to use the customer_id, employee_id, and product_id values you obtained from the SELECT statements. You have to use the order_id for the order record you created in the line_items records. The inserts must occur within the scope of one transaction. Then, using a SELECT with a JOIN, print out the list of line_item_ids for the order along with the quantity and product name for each.\n\n   You want to make sure that the foreign keys in the INSERT statements are valid.  So, add this line to your script, right after the database connection:\n   ```\n   conn.execute(\"PRAGMA foreign_keys = 1\")\n   ```\n\n   In general, when creating a record, you don't want to specify the primary key.  So leave that column name off your insert statements.  SQLite will assign a unique primary key for you.  But, you need the order_id for the order record you insert to be able to insert line_item records for that order.  You can have this value returned by adding the following clause to the INSERT statement for the order:\n   ```\n   RETURNING order_id\n   ```\n\n2. **Deliverable**:   \n   - Get this working in sqlcommand.  (Note that sqlcommand does not provide a way to begin and end transactions, so for sqlcommand, the creation of the order and line_item records are separate transactions.)\n   - Use sqlcommand to delete the line_items records for the order you created.  (This is one delete statement.)  Delete also the order record you created.\n   - Add statements for the complete transaction and the subsequent SELECT statement into `advanced_py.sql`, and to print out the result of the SELECT.\n   - Test your program.\n\n---\n\n### **Task 4: Aggregation with HAVING**\n\n1. **Problem Statement**:  \n   Find all employees associated with more than 5 orders.  You want the first_name, the last_name, and the count of orders.  You need to do a `JOIN` on the employees and orders tables, and then use GROUP BY, COUNT, and HAVING.\n\n2. **Deliverable**:  \n   - Get it working in sqlcommand.\n   - Add code `advanced_sql.py` to print out the employee_id, first_name, last_name, and an order count for each of the employees with more than 5 orders.\n   - Test your program.\n\n### Submit Your Assignment on GitHub**  \n\nüìå **Follow these steps to submit your work:**  \n\n#### **1Ô∏è‚É£ Add, Commit, and Push Your Changes**  \n- Within your python_homework folder, do a git add and a git commit for the files you have created, so that they are added to the `assignment9` branch.\n- Push that branch to GitHub. \n\n#### **2Ô∏è‚É£ Create a Pull Request**  \n- Log on to your GitHub account.\n- Open your `python_homework` repository.\n- Select your `assignment9` branch.  It should be one or several commits ahead of your main branch.\n- Create a pull request.\n\n#### **3Ô∏è‚É£ Submit Your GitHub Link**  \n- Your browser now has the link to your pull request.  Copy that link. \n- Paste the URL into the **assignment submission form**. \n\n---\n\n### **Resources**\n- [SQLite Documentation](https://www.sqlite.org/docs.html)\n- [Python `sqlite3` Library Documentation](https://docs.python.org/3/library/sqlite3.html)\n```\n",
        "codeExample": "",
        "_id": "68796c79a4ac7ef2a17a6192"
      }
    ],
    "submissionInstructions": "Please submit on time",
    "checklist": [],
    "checkForUnderstanding": []
  },
  "subsections": [
    {
      "subsectionOrder": 1,
      "title": "Lesson 9",
      "content": "# **Lesson 09 ‚Äî Advanced SQL and Database Integration**\n\n## **Lesson Overview**\n**Learning objective:** Students will deepen their understanding of SQL by learning advanced techniques such as subqueries, complex `JOIN`s, aggregation with functions, and using `HAVING` for conditional filtering. This lesson also introduces performance optimization techniques, transactions, parameterized queries, window functions, and more.\n\n**Topics:**\n1. Subqueries: Embedding queries within other SQL statements for dynamic filtering or calculations.\n2. Complex JOINs: Using INNER and LEFT JOINs across multiple related tables.\n3. Aggregation Functions: Using `MIN()`, `MAX()`, `AVG()`, `COUNT()` with `GROUP BY`.\n4. Aggregation with HAVING: Filtering grouped results using `HAVING` after aggregation.\n5. Performance Optimization: Creating indexes to speed up frequent queries.\n6. Transactions and Rollbacks: Ensuring consistency with `BEGIN`, `COMMIT`, and `ROLLBACK`.\n7. Parameterized Queries: Preventing SQL injection using safe input handling with placeholders.\n8. Window Functions: Applying `RANK()`, `ROW_NUMBER()`, and `OVER()` for row-level analytics.\n9. Date and Time Functions: Calculating durations and extracting date components using `JULIANDAY()` and related functions.\n10. Python Integration: Writing and executing SQL queries within Python scripts using `sqlite3`.\n\n---\n\n## **8.1 Understanding Subqueries**\n\n### **Overview**\nSubqueries are nested SQL queries used to perform intermediate calculations or selections before the main query executes.\n\n### **Key Concepts:**\n- Use subqueries to fetch results dynamically within another query.\n- Common use cases include finding maximum, minimum, or aggregated values.\n\n### **Example:**\nFind the highest-paid employee in each department using a subquery.\n```sql\nSELECT department_id, employee_id, salary\nFROM Employees AS e\nWHERE salary = (\n    SELECT MAX(salary)\n    FROM Employees\n    WHERE department_id = e.department_id\n);\n```\n\n### **Implementation in Python:**\n```python\n# Example using SQLite\nconn = sqlite3.connect(\"company.db\")\ncursor = conn.cursor()\n\n# Execute the query\nquery = \"\"\"\nSELECT department_id, employee_id, salary\nFROM Employees AS e\nWHERE salary = (\n    SELECT MAX(salary)\n    FROM Employees\n    WHERE department_id = e.department_id\n);\n\"\"\"\ncursor.execute(query)\nprint(cursor.fetchall())\n\nconn.close()\n```\n\n---\n\n## **8.2 Complex JOINs**\n\n### **Overview**\nComplex `JOIN`s allow you to retrieve data from multiple related tables.\n\n### **Steps:**\n1. Create a `Projects` table and insert sample data.\n2. Use a `JOIN` to combine employee and project information through the department field.\n\n### **Key Concepts:**\n- `INNER JOIN`: Retrieves records with matching values in both tables.\n- `LEFT JOIN`: Retrieves all records from the left table and matching records from the right.\n\n### **SQL Example: Create and Populate a Projects Table**\n```sql\nCREATE TABLE Projects (\n    id INTEGER PRIMARY KEY,\n    name TEXT NOT NULL,\n    department TEXT NOT NULL\n);\n\nINSERT INTO Projects (name, department) VALUES\n('Project A', 'HR'),\n('Project B', 'IT'),\n('Project C', 'Finance');\n```\n\n### **SQL Example: Complex JOIN**\nList employees working in departments responsible for a specific project:\n```sql\nSELECT Employees.name, Projects.name AS project_name\nFROM Employees\nJOIN Projects ON Employees.department = Projects.department\nWHERE Projects.name = 'Project A';\n```\n\n---\n\n## **8.3 Aggregation**\n\n### **Overview**\nAggregation functions like `MIN()`, `MAX()`, `COUNT()`, and `AVG()` allow you to summarize data across groups.\n\n### **Task:**\nCalculate the minimum and maximum salaries and the number of employees in each department.\n\n### **SQL Example:**\n```sql\nSELECT department_id, \n       MIN(salary) AS min_salary, \n       MAX(salary) AS max_salary, \n       COUNT(employee_id) AS num_employees\nFROM Employees\nGROUP BY department_id;\n```\n\n### **Key Notes:**\n- Use `GROUP BY` to organize results by department.\n- Ensure fields in the `SELECT` clause are either aggregated or part of the `GROUP BY`.\n\n---\n\n## **8.4 Aggregation with HAVING**\n\n### **Overview**\nThe `HAVING` clause filters aggregated results after the `GROUP BY` operation.\n\n### **Task:**\nList all departments where the average salary exceeds 70,000 and display the department manager.\n\n### **SQL Example:**\n```sql\nSELECT d.department_name, \n       d.manager_id, \n       AVG(e.salary) AS avg_salary\nFROM Departments AS d\nJOIN Employees AS e ON d.department_id = e.department_id\nGROUP BY d.department_id\nHAVING AVG(e.salary) > 70000;\n```\n\n### **Key Notes:**\n- Use `HAVING` instead of `WHERE` to filter aggregated results.\n- Combine `JOIN`s and `GROUP BY` for advanced aggregations.\n\n---\n\n## **8.5 Performance Optimization: Indexing**\n\n### **Overview**\nSQL queries can sometimes be slow if they involve large tables. Indexes can be created on columns that are frequently used in `WHERE`, `JOIN`, or `ORDER BY` clauses to speed up query performance.\n\n### **SQL Example:**\n```sql\nCREATE INDEX idx_department ON Employees(department_id);\n```\n\nThis creates an index on the `department_id` column to speed up queries that filter by department.\n\n---\n\n## **8.6 Transactions and Rollbacks**\n\n### **Overview**\nTransactions ensure that multiple database operations are completed successfully before committing them. If an error occurs, you can roll back the changes to keep the database in a consistent state.\n\n### **Example:**\n```python\n# Start a transaction\nconn = sqlite3.connect(\"company.db\")\ncursor = conn.cursor()\n\ntry:\n    cursor.execute(\"INSERT INTO Employees (name, department_id) VALUES ('John Doe', 2)\")\n    cursor.execute(\"INSERT INTO Employees (name, department_id) VALUES ('Jane Smith', 3)\")\n    conn.commit()  # Commit transaction\nexcept Exception as e:\n    conn.rollback()  # Rollback transaction if there's an error\n    print(\"Error:\", e)\n\nconn.close()\n```\n\n---\n\n## **8.7 Parameterized Queries to Prevent SQL Injection**\n\n### **Overview**\nSQL injection can be prevented by using parameterized queries, ensuring that user input is treated safely.\n\n### **Example:**\n```python\ncursor.execute(\"SELECT * FROM Employees WHERE department_id = ?;\", (department_id,))\n```\n\nThis ensures that `department_id` is treated as a parameter and not part of the SQL statement itself.  If any part of the SQL statement comes from the end user or other untrusted source, always put that part in a parameter so that it can be sanitized to strip out rogue SQL.  Don't do it like this:\n\n```python\ncursor.execute(f\"SELECT * FROM Employees WHERE department_id = {department_id};\")\n# or, equally bad:\ncursor.execute(\"SELECT * FROM Employees WHERE department_id = \" + department_id + \";\")\n```\n\n---\n\n## **8.8 Window Functions**\n\n### **Overview**\nSQL window functions allow for advanced analysis over a specified range of rows. For example, calculating the rank of employees within a department based on salary.\n\n### **SQL Example:**\n```sql\nSELECT name, salary, department_id,\n       RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS rank\nFROM Employees;\n```\n\n---\n\n## **8.9 Date and Time Functions**\n\n### **Overview**\nSQL provides functions for manipulating and querying date and time data, which are useful when working with time-based analysis.\n\n### **SQL Example:**\n```sql\nSELECT name, date_of_birth, \n       JULIANDAY('now') - JULIANDAY(date_of_birth) AS age_in_days\nFROM Employees;\n```\n\n---\n\n## **8.10 Implementing All Techniques in Python**\n\n### **Implementation Tips**\n\n1. **Test Queries Separately:**\n   - Write and test each query independently in your script or database interface before integrating into Python.\n\n2. **Iterative Debugging:**\n   - Verify intermediate outputs (e.g., after `JOIN` or subquery execution).\n\n3. **Error Handling in Python:**\n   - Use `try-except` blocks to handle database connection errors.\n\n### **Example Python Script:**\n```python\nimport sqlite3\n\n# Connect to the database\nconn = sqlite3.connect(\"company.db\")\ncursor = conn.cursor()\n\n# Aggregation with HAVING\nquery = \"\"\"\nSELECT d.department_name, \n       d.manager_id, \n       AVG(e.salary) AS avg_salary\nFROM Departments AS d\nJOIN Employees AS e ON d.department_id = e.department_id\nGROUP BY d.department_id\nHAVING AVG(e.salary) > 70000;\n\"\"\"\n\n# Execute and fetch results\ncursor.execute(query)\nresults = cursor.fetchall()\nprint(results)\n\nconn.close()\n```\n\n---\n\n## **Summary**\n\nIn this lesson, you‚Äôve learned:\n1. How to use subqueries to dynamically fetch values for other queries.\n2. How to use complex `JOIN`s to integrate data from multiple tables.\n3. How to use aggregation functions to summarize data across groups.\n4. How to apply `HAVING` for conditional filtering on aggregated data.\n5. How to optimize performance with indexes.\n6. How to use transactions and rollbacks to ensure data consistency.\n7. How to prevent SQL injection with parameterized queries.\n8. How to use window functions for advanced analytics.\n9. How to handle date and time data for time-based analysis.\n\nFor further exploration, refer to the [SQLite Documentation](https://www.sqlite.org/docs.html) and Python's `sqlite3` library documentation.\n",
      "videoUrl": "",
      "codeExamples": [],
      "externalLinks": [],
      "quizzes": [],
      "_id": "68796c79a4ac7ef2a17a6191"
    }
  ]
}