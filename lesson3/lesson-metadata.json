{
  "id": "68796c78a4ac7ef2a17a6178",
  "lessonNumber": 3,
  "title": "Lesson 3 — More Python Skills",
  "status": "pending",
  "assignment": {
    "title": "Assignment for Lesson 3",
    "objective": "No objective specified",
    "expectedCapabilities": [],
    "instructions": [],
    "tasks": [
      {
        "taskNumber": 1,
        "title": "Task 1",
        "description": "# **Lesson 03: More Python Skills**\n\n## **Assignment 3 Objective**\n\nIn this assignment, you will get practice in using decorators, list comprehensions, closures, and custom classes.\n\n## **Assignment Instructions**\n\nYou create the code for this assignment in your python_homework/assignment3 folder.  Be sure to create an `assignment3` git branch before you start.  As usual, mark the code that completes each task with a comment line.\n\n---\n\n## **Task 1: Writing and Testing a Decorator**\n\n1. Within the assignment3 folder, create a file called `log-decorator.py`.  It should contain the following.\n2. Declare a decorator called logger_decorator.  This should log the name of the called function (`func.__name__`), the input parameters of that were passed, and the value the function returns, to a file `./decorator.log`.  (Logging was described in lesson 1, so review this if you need to do so.)  Functions may have positional arguments, keyword arguments, both, or neither.  So for each invocation of a decorated function, the log would have:\n    ```\n    function: <the function name>\n    positional parameters: <a list of the positional parameters, or \"none\" if none are passed>\n    keyword parameters: <a dict of the keyword parameters, or \"none\" if none are passed>\n    return: <the return value>\n    ```\n    Here's a cookbook on logging:\n    ```python\n    # one time setup\n    import logging\n    logger = logging.getLogger(__name__ + \"_parameter_log\")\n    logger.setLevel(logging.INFO)\n    logger.addHandler(logging.FileHandler(\"./decorator.log\",\"a\"))\n    ...\n    # To write a log record:\n    logger.log(logging.INFO, \"this string would be logged\")\n    ```\n3. Declare a function that takes no parameters and returns nothing.  Maybe it just prints \"Hello, World!\".  Decorate this function with your decorator.\n4. Declare a function that takes a variable number of positional arguments and returns `True`.  Decorate this function with your decorator.\n5. Declare a function that takes no positional arguments and a variable number of keyword arguments, and that returns `logger_decorator`.  Decorate this function with your decorator.\n6. Within the mainline code, call each of these three functions, passing parameters for the functions that take positional or keyword arguments.  Run the program, and verify that the log file contains the information you want.\n\n---\n\n## **Task 2: A Decorator that Takes an Argument**\n\n1. Within your assignment3 folder, write a script called `type-decorator.py`.\n2. Declare a decorator called type_converter.  It has one argument called `type_of_output`, which would be a type, like `str` or `int` or `float`.  It should convert the return from `func` to the corresponding type, viz:\n   ```python\n   x = func(*args, **kwargs)\n   return type_of_output(x)\n   ```\n3. Write a function `return_int()` that takes no arguments and returns the integer value 5.  Decorate that function with type-decorator.  In  the decoration, pass `str` as the parameter to type_decorator.\n4. Write a function `return_string()` that takes no arguments and returns the string value \"not a number\".  Decorate that function with type-decorator.  In the decoration, pass `int` as the parameter to type_decorator.  Think: What's going to happen?\n5. In the mainline of the program, add the following:\n   ```python\n   y = return_int()\n   print(type(y).__name__) # This should print \"str\"\n   try:\n      y = return_string()\n      print(\"shouldn't get here!\")\n   except ValueError:\n      print(\"can't convert that string to an integer!\") # This is what should happen\n   ```\n\n---\n\n## **Task 3: List Comprehensions Practice**\n\n1. Within the assignment3 folder, create a file called `list-comprehensions.py`. Add code that reads the contents of `../csv/employees.csv` into a list of lists using the csv module.\n2. Using a list comprehension, create a list of the employee names, first_name + space + last_name.  The list comprehension should iterate through the items in the list read from the csv file.  Print the resulting list.  Skip the item created for the heading of the csv file.\n3. Using a list comprehension, create another list from the previous list of names.  This list should include only those names that contain the letter \"e\".  Print this list.\n\n---\n\n## **Task 4: Closure Practice**\n\n1. Within the assignment3 folder, create a file called `hangman-closure.py`.\n2. Declare a function called `make_hangman()` that has one argument called secret_word.  It should also declare an empty array called guesses.  Within the function declare a function called hangman_closure() that takes one argument, which should be a letter.  Within the inner function, each time it is called, the letter should be appended to the guesses array.  Then the word should be printed out, with underscores substituted for the letters that haven't been guessed.  So, if secret_word is \"alphabet\", and guesses is [\"a\", \"h\"], then \"a__ha__\" should be printed out.  The function should return `True` if all the letters have been guessed, and `False` otherwise.  `make_hangman()` should return `hangman_closure`.\n3. Within hangman-closure.py, implement a hangman game that uses make_hangman().  Use the input() function to prompt for the secret word.  Then use the input() function to prompt for each of the guesses, until the full word is guessed.\n4. Test your program by playing a few games.\n\n## **Task 5: Extending a Class**\n\n1. Within the assignment3 folder, create a file called `extend-point-to-vector.py`.\n2. Create a class called `Point`.  It represents a point in 2d space, with x and y values passed to the `__init__()` method.  It should include methods for equality, string representation, and Euclidian distance to another point.\n3. Create a class called `Vector` which is a subclass of `Point` and uses the same `__init__()` method.  Add a method in the vector class which overrides the string representation so `Vector`s print differently than `Point`s.  Override the `+` operator so that it implements vector addition, summing the `x` and `y` values and returning a new `Vector`.\n4. Print results which demonstrate all of the classes and methods which have been implemented.\n\n## **Task 6: More on Classes**\n\n1. Within the assignment3 folder, create a file called `tictactoe.py`.\n2. Within this file, declare a class called TictactoeException.  This should inherit from the Exception class.  Add an `__init__` method that stores an instance variable called `message` and then calls the `__init__` method of the superclass.  This is a common way of creating a new type of exception.\n3. Declare also a class called Board.  This should have an `__init__` function that only has the `self` argument.  It creates a list of lists, 3x3, all git containing \" \" as a value.  This is stored in the variable self.board_array.  Create instance variables self.turn, which is initialized to \"X\".  The Board class should have a class variable called valid_moves, with the value:\n```python\n   valid_moves=[\"upper left\", \"upper center\", \"upper right\", \"middle left\", \"center\", \"middle right\", \"lower left\", \"lower center\", \"lower right\"]\n```\n4. Add a `__str__()` method.  This converts the board into a displayable string.  You want it to show the current state of the game. The rows to be displayed are separated by newlines (\"\\n\") and you also want some \"|\" amd \"-\" characters.  Once you have created this method, you can display the board by doing a `print(board)`.\n4. Add a move() method.  This has two arguments, `self` and `move_string`.  The following strings are valid in TicTacToe: \"upper left\", \"upper center\", \"upper right\", \"middle left\", \"center\", \"middle right\", \"lower left\", \"lower center\", and \"lower right\".  When a string is passed, the move() method will check if it is one of these, and if not it will raise a TictactoeException with the message \"That's not a valid move.\".  Then the move() method will check to see if the space is taken.  If so, it will raise an exception with the message \"That spot is taken.\"  If neither is the case, the move is valid, the corresponding entry in board_array is updated with X or O, and the turn value is changed from X to O or from O to X.  It also updates last_move, which might make it easier to check for a win.\n5. Add a whats_next() method.  This will see if the game is over.  If there are 3 X's or 3 O's in a row, it returns a tuple, where the first value is True and the second value is either \"X has won\" or \"O has won\".  If the board is full but no one has won, it returns a tuple where the first value is True and the second value is \"Cat's Game\".  Otherwise, it returns a tuple where the first value is False and the second value is either \"X's turn\" or \"O's turn\".\n6. Implement the game within the mainline code of `tictactoe.py`.  At the start of the game, an instance of the board class is created, and then the methods of the board class are used to progress through the game.  Use the `input()` function to prompt for each move, indicating whose turn it is.  Note that you need to call board.move() within a try block, with an except block for TictactoeException.  Give appropriate information to the user.\n7. Test your program by playing a few games.\n\nOn assembling this program, the assignment author found that it was too time consuming to write some of the methods.  So, here are some pieces to reuse.  Please make sure you understand them.\n```python\n    def __str__(self):\n        lines=[]\n        lines.append(f\" {self.board_array[0][0]} | {self.board_array[0][1]} | {self.board_array[0][2]} \\n\")\n        lines.append(\"-----------\\n\")\n        lines.append(f\" {self.board_array[1][0]} | {self.board_array[1][1]} | {self.board_array[1][2]} \\n\")\n        lines.append(\"-----------\\n\")\n        lines.append(f\" {self.board_array[2][0]} | {self.board_array[2][1]} | {self.board_array[2][2]} \\n\")\n        return \"\".join(lines)\n    \n    def move(self, move_string):\n        if not move_string in Board.valid_moves:\n            raise TictactoeException(\"That's not a valid move.\")\n        move_index = Board.valid_moves.index(move_string)\n        row = move_index // 3 # row\n        column = move_index % 3 #column\n        if self.board_array[row][column] != \" \":\n            raise TictactoeException(\"That spot is taken.\")\n        self.board_array[row][column] = self.turn\n        if self.turn == \"X\":\n            self.turn = \"O\"\n        else:\n            self.turn = \"X\"\n    \n    def whats_next(self):\n        cat = True\n        for i in range(3):\n            for j in range(3):\n                if self.board_array[i][j] == \" \":\n                    cat = False\n                else:\n                    continue\n                break\n            else:\n                continue\n            break\n        if (cat):\n            return (True, \"Cat's Game.\")\n        win = False\n        for i in range(3): # check rows\n            if self.board_array[i][0] != \" \":\n                if self.board_array[i][0] == self.board_array[i][1] and self.board_array[i][1] == self.board_array[i][2]:\n                    win = True\n                    break\n        if not win:\n            for i in range(3): # check columns\n                if self.board_array[0][i] != \" \":\n                    if self.board_array[0][i] == self.board_array[1][i] and self.board_array[1][i] == self.board_array[2][i]:\n                        win = True\n                        break\n        if not win:\n            if self.board_array[1][1] != \" \": # check diagonals\n                if self.board_array[0][0] ==  self.board_array[1][1] and self.board_array[2][2] == self.board_array[1][1]:\n                    win = True\n                if self.board_array[0][2] ==  self.board_array[1][1] and self.board_array[2][0] == self.board_array[1][1]:\n                    win = True\n        if not win:\n            if self.turn == \"X\": \n                return (False, \"X's turn.\")\n            else:\n                return (False, \"O's turn.\")\n        else:\n            if self.turn == \"O\":\n                return (True, \"X wins!\")\n            else:\n                return (True, \"O wins!\")\n```\n\n---\n\n\n### Submit Your Assignment on GitHub**  \n\n📌 **Follow these steps to submit your work:**  \n\n#### **1️⃣ Add, Commit, and Push Your Changes**  \n- Within your python_homework folder, do a git add and a git commit for the files you have created, so that they are added to the `assignment3` branch.\n- Push that branch to GitHub. \n\n#### **2️⃣ Create a Pull Request**  \n- Log on to your GitHub account.\n- Open your `python_homework` repository.\n- Select your `assignment3` branch.  It should be one or several commits ahead of your main branch.\n- Create a pull request.\n\n#### **3️⃣ Submit Your GitHub Link**  \n- Your browser now has the link to your pull request.  Copy that link. \n- Paste the URL into the **assignment submission form**. \n\n---\n",
        "codeExample": "",
        "_id": "68796c78a4ac7ef2a17a617a"
      }
    ],
    "submissionInstructions": "Please submit on time",
    "checklist": [],
    "checkForUnderstanding": []
  },
  "subsections": [
    {
      "subsectionOrder": 1,
      "title": "Lesson 3",
      "content": "\n# Lesson 3 — More Python Skills\n\n## Lesson Overview\n**Learning objective:** In this lesson, students will learn and apply key advanced Python concepts including object-oriented programming, decorators, list comprehensions, and closures. They will learn how to write cleaner, more modular code using these features, and gain insight into how such patterns are used in real-world frameworks like Dash.\n\n### Topics\n1. Object-oriented programming (OOP)\n2. Decorators\n3. List comprehensions\n4. Closures\n---\n\n## 10.1 Object-oriented programming in Python\nEverything in Python is an object, and objects are instances of *classes*. That means when you create a variable like a string, list, or even a function — you’re actually creating an object. Before finishing Python 100, it's worth understanding what this actually means.  \n\nUntil now we have been following principles of *functional programming*: writing standalone functions that take in inputs, return outputs, and typically don't remember anything between calls. But sometimes we want to bundle together data and the functions -- called *methods* -- that operate on that data. This is the core idea of object-oriented programming (OOP). This bundling is called *encapsulation*, and helps keep related code organized in one place. If you are creating a new data type, OOP lets you define not only what that data type is, but what you can do with it. \n\n> If you want to go a little deeper, there is a nice overview of OOP at [Real Python](https://realpython.com/python3-object-oriented-programming/). \n\n### Basic class definition\nLet’s look at a very simple example — a class that represents dogs:\n\n```Python\nclass Dog:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def call_dog(self):\n        print(f\"Come here, {self.name}!\")\n\n    def speak(self):\n        print(\"bark bark bark\")\n\ndog1 = Dog(\"Spot\", 2)\ndog1.call_dog()\ndog1.speak()\nprint(f\"dog1's name is {dog1.name}.\")\n\ndog2 = Dog(\"Wally\", 4)\ndog2.call_dog()\ndog2.age += 1\nprint(dog2.age)\n```\n\nIn the above, we have:\n- The declaration of a class named `Dog`.  Unlike functions, class names are capitalized in Python.\n- An initialization method `__init__()` that runs automatically when you create a new dog. Here, the method is used to set the initial values of the object's attributes (`name` and `age`). \n- You can access an object's attributes using *dot notation*: this includes both instance variables and methods.\n- The object's instance variables `self.name` and `self.age` store data for each instance of the class.\n- The two methods, `call_dog()` and `speak()` are always passed the value  `self`, which gives them access to attributes like `name` or `age`. \n- Notice that we were able to modify `dog2`'s age -- there is nothing truly private about the data stored in an object's attributes. We will say more about this below. \n\n#### What is `self`?\nWithin a class definition, `self` refers to the current instance of the class — the specific object the method is being called on. It can be a little confusing because when *defining* a method it is always the first parameter, but you don’t actually pass it in as a parameter when invoking the method; Python does that automatically behind the scenes. For instance, above we have `dog1.call_dog()`, which doesn't include the `self` argument explicitly. \n\n### Expanding the class: class attributes and class methods\nWe can add more bells and whistles to our simple Dog class. For example, suppose we want to count how many dogs have been created. Instead of storing that information in each individual dog, we can store it once at the class level:\n\n```Python\nclass Dog:\n    _count = 0  \n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n        Dog._count += 1 \n\n    def call_dog(self):\n        print(f\"Come here, {self.name}!\")\n\n    def speak(self):\n        print(\"bark bark bark\")\n\n    @classmethod\n    def get_dog_count(cls):\n        return cls._count\n\n# Create a couple of dogs\ndog1 = Dog(\"Spot\", 2)\ndog1.call_dog()\ndog1.speak()\nprint(f\"dog1's name is {dog1.name}.\")\n\ndog2 = Dog(\"Wally\", 4)\ndog2.call_dog()\ndog2.age += 1\nprint(f\"dog2's new age: {dog2.age}\")\n\nprint(f\"Total dogs created: {Dog.get_dog_count()}\")  \n```\nThere are quite a few new things going on here:\n- The variable `_count` is a *class variable*. Unlike the instance variables like `name` and `age`, it belongs to the class itself — not any individual dog. This means it is shared across all `Dog` objects. You can tell it is a class variables because it is defined outside the `__init__()` method.\n- The `_count` variable starts with a single underscore to signal that it’s intended for internal use. This is a common Python convention: it doesn’t make the variable truly private (it is still accessible), but it tells developers that it isn't meant to be directly accessed and modified. \n- The method `get_dog_count()` is a *class method*, declared using the `@classmethod` decorator (we will talk more about decorators below). This tells Python that the method operates on the `Dog` class rather than individual objects.\n- Instead of taking `self` as the first parameter,  `get_dog_count()` takes in `cls` (short for *class*). `cls` allows us to access the class-level variable `_count`.\n\n### Class inheritance\nSuppose you want to create a class that’s similar to `Dog`, but with a few differences — maybe a bigger bark, or a new behavior like fetching. Instead of rewriting everything from scratch, Python (and OOP in general) lets you *inherit* from an existing class and customize only the parts you want. This is called *class inheritance*.\n\nHere's an example where we create a class `BigDog` that explicitly inherits from `Dog`:\n\n```Python\nclass BigDog(Dog): # inherits from Dog\n    def __init__(self, name, age): \n        # Call the parent class's __init__ to set name/age\n        super().__init__(name, age) \n\n    def fetch(self):\n        print(\"Got it.\")\n\n    def speak(self):\n        print(\"Woof Woof Woof\") # overrides Dog.speak()\n\n    def speak_verbose(self):\n        # call Dog.speak(), then BigDog.speak()\n        super().speak()\n        self.speak()\n\ndog3 = BigDog(\"Butch\", 3)\ndog3.call_dog()\ndog3.speak()\ndog3.speak_verbose()\n```\n\nHere, the `BigDog` class inherits from the `Dog` class, meaning it gets all of `Dog`’s methods and attributes unless explicitly changed:\n- The `call_dog()` method is inherited from `Dog`, because we didn’t override it.\n- The `speak()` method is overridden to make big dogs sound different.\n- The `speak_verbose()` method shows how to call both the original `Dog.speak()` (using `super()`) and `BigDog.speak()`.\n\nYou might try creating a `ShyDog` class that overrides `speak()` to say nothing unless prompted by giving it a treat with a method `give_treat()`.\n\n### A few other facts about classes\nA useful attribute of every class and instance is `__dict__`.\n\n```python\nprint(Dog.__dict__) # prints attributes and methods for the Dog class\nprint(dog1.__dict__) # prints the attributes of the instance and their values.\n```\n\nYou can also create classes from system classes:\n\n```Python\nclass Shout(str):\n   def __new__(cls, content):\n      return str.__new__(cls, content.upper())\n\nx = Shout(\"hello there\")\nprint(x) # prints HELLO THERE\n```\nIn this case, the subclass overrides the `__new__` method of the `str` class, and not the `__init__` method, because strings are immutable. \n\n---\n\n## 10.2: Introduction to Decorators\nWe’ve already seen some decorators like `@classmethod` in our class definitions. But what are these things? A decorator is syntactic sugar that says, “Take this function or class, and pass it through another function to modify it.” You will probably *use* decorators more than you write them in Python, so let's see them in action to see how useful they can be.   \n\n#### Examples of decorators\nPython provides lots of built-in decorators. We've already seen one:\n\n```Python\n@classmethod\ndef get_dog_count(cls):\n```\nThis tells Python: “Don’t treat `get_dog_count()` like a normal method. Treat it as a method that applies to the class itself.” That’s all a decorator is doing: changing the behavior of a function or method, without you having to rewrite that function.\n\nThere are *many* useful built-in decorators. Sometimes, we want a method in a class to act like an attribute — it does a calculation, but we want to access it without parentheses:\n\n```Python\nclass Circle:\n    def __init__(self, radius):\n        self.radius = radius\n\n    @property\n    def area(self):\n        return 3.14 * self.radius ** 2\n\n    @property\n    def diameter(self):\n        return 2 * self.radius\n```\n\nNow you can access those properties (area and diameter) as if they were attributes of the object, using dot notation: \n\n```Python\nc = Circle(3)\nprint(c.area)    \nprint(c.diameter)  \n```\nAnother nice feature is that while `area` and `diameter` are calculated using methods, if you change the `radius`, they will automatically repopulate with the correct values without you having to re-run those methods:\n\n```Python\nc.radios = 5\nprint(c.area)\n```\nYou didn't have to re-assign anything: `area` (and `diamater`) are always recalculated based on the current radius. \n\n`@property` and `@classmethod` are built-in Python decorators -- Python itself provides this functionality. Below, we will discuss how to write your own decorators. \n\nSo far we’ve seen decorators used with functions and methods, like `@property` and `@classmethod`. However, decorators can also be used with *classes*. One useful example is the built-in `@dataclass` decorator, which lets you quickly and conveniently define simple classes for storing structured data, without needing an `__init__` method.\n\n```Python\nfrom dataclasses import dataclass\n\n@dataclass\nclass Book:\n    title: str\n    author: str\n\nbook1 = Book(\"Dune\", \"Frank Herbert\")\nbook2 = Book(\"Dune\", \"Frank Herbert\")\nbook3 = Book(\"Neuromancer\", \"William Gibson\")\n\nprint(book1)\nprint(book2.title)          \nprint(book1 == book2) # True — same data, so considered equal\nprint(book1 == book3) # False — different data\n```\nThere are a few things to notice about `dataclass` objects:\n- You didn’t have to write an `__init__` method or any other methods for the class: Python did it for you behind the scenes. You just declare the attribute names and their data types.\n- You can access the attributes of a book object using standard dot notation (`book2.title`). \n- You can check if two different books are the same with `book1 == book2` without having to define your own `__eq__()` operator.  \n\n### Writing your own decorators\nPython classifies functions as first-class objects, which means you can treat them just like any other variable or object. That is, you can pass them as arguments to other functions. For instance:\n\n```Python\ndef say_hello():\n    print(\"Hello!\")\n\ndef repeat_me(func, num_repeats):\n    for _ in range(num_repeats):\n        func()\n\nrepeat_me(say_hello, 5)  # Will print \"Hello!\" 5x\n```\nThis simple example demonstrates how you can pass around functions such as `say_hello()` and call them dynamically in your scripts. \n\nDecorators take advantage of this, and make such function application cleaner and easier to read. Let's look at a simple example, your first hand-made decorator: \n\n```python\ndef my_decorator(func):\n    def wrapper():\n        print (\"Hello!\")\n        func()\n        print (\"World!\")\n    return wrapper\n\n@my_decorator\ndef print_name():\n    print(\"John\")\n\nprint_name()\n```\n\nThe output of `print_name()`, which is modified with the decorator, will be:\n```\nHello!\nJohn\nWorld!\n```\nWhat's happening here?\n- The decorator function `my_decorator()` takes a function (`func`) as input. \n- Inside this function, you define a new function called `wrapper()` that does three things: it prints \"Hello!\", calls the original function `func()` (which prints the name \"John\"), and then prints \"World!\". \n- The decorator returns the new `wrapper()` function that includes this extra behavior that is wrapped around `func()`. \n- When you add the `@my_decorator` above the `print_name()` function declaration, Python runs the following behind the scenes:\n\n```Python\nprint_name = my_decorator(print_name)\n```\nDecorators let you add behavior to a function without modifying its original code. You didn’t have to touch `print_name()` -- you just wrapped it.\n\nIn this example the function is fairly trivial, however in the next section we can dig into some more useful examples. \n\n### Decorator that will work with any function\n\nHere is an example of a decorator that allows us to benchmark different sections of code. We need to allow all functions to go into this decorator, and it will print out the time it took for a function to complete.\n```python\nimport time\n\ndef timer(func):\n    ## Output the time the inner function takes\n    def wrapper_timer(*args, **kwargs):\n        start_time = time.perf_counter()\n        value = func(*args, **kwargs)\n        end_time = time.perf_counter()\n        run_time = end_time - start_time\n        print (f\"Finished in {run_time:.4f} secs\")\n        return value\n    return wrapper_timer\n\n@timer\ndef wait_half_second():\n    time.sleep(0.5)\n    return \"Done\"\n\nwait_half_second()\n```\nThis provides a useful way to wrap any function to see how long it takes to run (here we are wrapping a function that simply waits for a half second to demonstrate how the decorator works). \n\nIn more detail:\n- `@timer` decorates the function `wait_half_second`.\n- Inside the wrapper, we:\n  - Record the start time\n  - Call the original function (`func(*args, **kwargs)`)\n  - Record the end time and complute the elapsed time.\n  - Print the elapsed time.\n- Why did we use `*args` and `**kwargs`? Those let the decorator work with *any* function, no matter how many arguments it takes. `*args` captures positional arguments, while `**kwargs` captures keyword arguments. This flexibility makes the wrapper reusable for any function. Go ahead and try it for other functions.\n  \n\n### Decorator with arguments: decorator factories\nSometimes you want to pass *arguments* into a decorator — like how many times to repeat something, or what prefix to add to a message.  In this case, you need two levels of wrapping. This is because decorators are called with just one argument: the function being decorated. If you want to pass extra arguments, you need a *decorator factory* — a function that creates a customized decorator based on the parameters you provide. \n\nLet's look at an example where we allow users to specify how many times a message is repeated, and what prefix to add:\n\n```Python\ndef repeat_with_prefix(prefix, num_repeats): # decorator factory\n    def decorator(func):  # The decorator: takes the function\n        def wrapper(*args, **kwargs):  # The wrapper: runs the function with extra behavior\n            for _ in range(num_repeats):\n                result = func(*args, **kwargs)  # Call the original function\n                print(f\"{prefix} {result}\")\n        return wrapper\n    return decorator\n\n@repeat_with_prefix(\">>\", 3)  \ndef greet(name):\n    return f\"Hello, {name}!\"\n\ngreet(\"Amanda\")\n```\nBreaking down the above. When you run `greet(\"Amanda\")` you get:\n\n```Python\n>> Hello, Amanda!\n>> Hello, Amanda!\n>> Hello, Amanda!\n```\nHere's what happened behind the scenes:\n- The decorator factory is called: `@repeat_with_prefix(\">>\", 3)` creates and returns a decorator function customized with the appropriate arguments.\n- The decorator wraps the function: The `decorator` function (returned by the factory) is applied to `greet`.\n- The wrapper runs the function: When you call `greet(\"Amanda\")`,  the wrapper function uses the `prefix` and `num_repeats` provided by the factory to add the prefix to each output and print the result (`num_repeat` times)\n\nFeel free to modify the code or the parameters (e.g., change \">>\" to \"**\" or 3 to 5) to see how the decorator’s behavior changes. Parameterized decorators are a powerful but advanced concept, so take your time to experiment and build your intuition.\n\n### Callback to Dash application\nDecorators are often used in another way.  They register a function that is to be called by system code.  For example, in the lesson on Dash, you had the following lines:\n\n```Python\n@app.callback(\n    Output(\"stock-price\", \"figure\"),\n    [Input(\"stock-dropdown\", \"value\")]\n)\ndef update_graph(symbol):\n```\nThe `app.callback` method runs before `update_graph()` is ever called.  It records the fact that `update_graph()`, as wrappered by the `app.callback` wrapper function, is to be called whenever the stock dropdown changes.  You could do something like this, registering the functions to be wrapped, as follows:\n\n```Python\ncallback_dict={}\n\ndef wrap_output(before, after,greeting_type):\n    def decorator_wrap_output(func):\n        callback_dict[greeting_type] = func\n        def wrapper(*args, **kwargs):\n            result = func(*args, **kwargs)\n            return before + result + after\n        callback_dict[greeting_type]=wrapper\n        return wrapper\n    return decorator_wrap_output\n\n@wrap_output(\"begin:\", \":end\",\"for_hello\")\ndef hello():\n    return \"Hello, World!\"\n\n@wrap_output(\"begin:\", \":end\",\"for_goodbye\")\ndef goodbye():\n    return \"Goodbye, World!\"\n\nprint(callback_dict[\"for_hello\"]()) # Will print \"begin:Hello, World!:end\"\n\nprint(callback_dict[\"for_goodbye\"]()) # Will print \"begin:Goodbye, World!:end\"\n```\n\nHere, the decorated functions, in their wrappered form, get registered for callbacks in `callback_dict`.  This is like what Dash is doing when you use the decorator `@app.callback`.\n\n---\n\n## **10.3 Python List Comprehensions**\n\n### **Overview**  \nA list comprehension is a fast and Pythonic way to generate a list.  For example, suppose you want a list of the integers from 0 to 19.  You could do\n\n```Python\ninteger_list=[]\nfor x in range(20):\n    integer_list.append(x)\n```\nbut, with Python, you can use a list comprehension as a shorthand:\n```Python\ninteger_list = [x for x in range(20)]\n```\nOr, to get just the odd ones:\n```Python\nodd_list = [x for x in range(20) if x%2 != 0]\n```\nOr, to get the squares of the odd ones:\n```Python\nodd_squares_list = [x**2 for x in range(20) if x%2 !=0]\n# or\nodd_squares_list = [x**2 for x in odd_list]\n```\n\n### **Generator Expressions**\n\nA generator expression is just like a list comprehension, except that you use parentheses instead of square brackets.  A generator expression is an `iterable`, meaning you can use it in a `for` loop.  Like so:\n\n```python\nodd_squares_generator = (x**2 for x in range(20) if x%2 !=0)\n\nfor y in odd_squares_generator:\n    print(y)\n\n```\n\n---\n\n## **10.4 Python Closures**\n\nA Python closure is a way of wrappering information by returning a function that has access to that information.  This provides some protection for the stuff you wrapper.  For example:\n\n```Python\ndef make_secret(secret):\n    def did_you_guess(guess):\n        if guess == secret:\n            print(\"You got it!\")\n        else:\n            print(\"Nope\")\n    return did_you_guess\n\ngame1 = make_secret(\"swordfish\")\ngame2 = make_secret(\"magic\")\n\ngame1(\"magic\") # Prints nope\ngame1(\"swordfish\") # Prints you got it\ngame2(\"magic\") # Prints you got it\n```\n\nOf course, the wrappered function could also store data, but you may need the `nonlocal` keyword.  This makes the variable still wrappered within the outer function, but accessible within the inner function:\n```Python\ndef make_secret(secret):\n    bad_guesses = 0\n    def did_you_guess(guess):\n        nonlocal bad_guesses\n        if guess == secret:\n            print(\"You got it!\")\n        else:\n            bad_guesses+=1\n            print(f\"Nope, bad guesses: {bad_guesses}\")\n    return did_you_guess\n\ngame1 = make_secret(\"swordfish\")\ngame1(\"magic\") # Prints nope, bad guesses 1\ngame1(\"magic\") # Prints nope, bad guesses 2\n```\n\n---\n\n\n## **Summary**\nIn this lesson, you learned:\n1. Declaring and Using Custom Python Classes\n2. How to use Python Decorators\n3. How to use Python List Comprehensions\n4. Closures in Python\n\n",
      "videoUrl": "",
      "codeExamples": [],
      "externalLinks": [],
      "quizzes": [],
      "_id": "68796c78a4ac7ef2a17a6179"
    }
  ]
}